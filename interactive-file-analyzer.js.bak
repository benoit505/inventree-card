// fixed-interactive-file-analyzer.js
const fs = require('fs');
const path = require('path');
const ts = require('typescript');
const readline = require('readline');

// Create readline interface for user input
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Directory to start searching from
const rootDir = './src';
// Store all function data
const allFunctions = [];
// Store function calls
const functionCalls = [];
// Store file metadata
const fileData = [];

// New data structures for enhanced analysis
const componentResponsibilities = {};
const circularDependencies = [];
const functionComplexityScores = {};
const moduleHeatMap = {};
const couplingMatrix = {};

// Analyze function responsibilities by looking for patterns in the code
function analyzeFunctionResponsibilities(node, sourceFile, functionName, filePath) {
  if (!functionName) return null;
  
  const functionText = node.getText(sourceFile);
  
  // Define patterns that indicate different responsibilities
  const patterns = {
    stateManagement: ['setState', 'getState', 'store.dispatch', 'useReducer', '_state'],
    uiRendering: ['render', 'html`', 'return html', 'template', 'innerHTML'],
    dataFetching: ['fetch', 'axios', 'api', 'getData', 'loadEntity'],
    eventHandling: ['addEventListener', 'removeEventListener', 'onClick', 'handleEvent'],
    serviceInitialization: ['initialize', 'getInstance', 'setupService', 'createService'],
    errorHandling: ['try', 'catch', 'throw', 'error\\(', 'log\\(error'],
    timerManagement: ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
  };
  
  // Count occurrences of each pattern
  const responsibilities = {};
  
  for (const [type, typePatterns] of Object.entries(patterns)) {
    const matchCount = typePatterns.reduce((count, pattern) => {
      const regex = new RegExp(pattern, 'g');
      const matches = functionText.match(regex);
      return count + (matches ? matches.length : 0);
    }, 0);
    
    responsibilities[type] = matchCount;
  }
  
  // Calculate a "responsibility spread" score - higher means the function does many different things
  const nonZeroResponsibilities = Object.values(responsibilities).filter(count => count > 0).length;
  responsibilities.responsibilitySpread = nonZeroResponsibilities;
  
  // Store the result
  if (!componentResponsibilities[filePath]) {
    componentResponsibilities[filePath] = {};
  }
  componentResponsibilities[filePath][functionName] = responsibilities;
  
  return responsibilities;
}

// Calculate cyclomatic complexity (approximation)
function calculateComplexity(node, sourceFile, functionName) {
  if (!functionName) return 0;
  
  const functionText = node.getText(sourceFile);
  
  // Basic complexity = 1
  let complexity = 1;
  
  // Add for each decision point
  const decisionPatterns = [
    /if\s*\(/g,
    /else\s*\{/g,
    /else\s+if\s*\(/g,
    /for\s*\(/g,
    /while\s*\(/g,
    /case\s+/g,
    /default\s*:/g,
    /&&/g,
    /\|\|/g,
    /\?/g,
    /catch\s*\(/g
  ];
  
  for (const pattern of decisionPatterns) {
    const matches = functionText.match(pattern);
    if (matches) {
      complexity += matches.length;
    }
  }
  
  // Store the complexity score
  functionComplexityScores[functionName] = complexity;
  
  return complexity;
}

// Process a TypeScript file
function processFile(filePath) {
  const fileContent = fs.readFileSync(filePath, 'utf8');
  const sourceFile = ts.createSourceFile(
    filePath,
    fileContent,
    ts.ScriptTarget.Latest,
    true
  );
  
  const relativePath = path.relative(rootDir, filePath);
  const lineCount = fileContent.split('\n').length;
  
  // File metadata
  fileData.push({
    path: relativePath,
    lineCount,
    functionCount: 0,
    imports: [],
    exports: []
  });
  
  const currentFileIndex = fileData.length - 1;
  
  // Track imports
  function collectImports(node) {
    if (ts.isImportDeclaration(node)) {
      let importPath = '';
      if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
        importPath = node.moduleSpecifier.text;
      }
      
      let importedItems = [];
      if (node.importClause) {
        if (node.importClause.name) {
          importedItems.push(node.importClause.name.text);
        }
        if (node.importClause.namedBindings) {
          if (ts.isNamedImports(node.importClause.namedBindings)) {
            importedItems = importedItems.concat(
              node.importClause.namedBindings.elements.map(el => el.name.text)
            );
          }
        }
      }
      
      fileData[currentFileIndex].imports.push({
        path: importPath,
        items: importedItems
      });
      
      // Track module imports for heat map
      if (importPath.startsWith('.')) {
        const moduleName = importPath.split('/').filter(Boolean).slice(0, 2).join('/');
        if (!moduleHeatMap[moduleName]) {
          moduleHeatMap[moduleName] = 0;
        }
        moduleHeatMap[moduleName]++;
      }
    }
    
    // Track exports
    if (ts.isExportDeclaration(node) || 
        (ts.isFunctionDeclaration(node) && node.modifiers && 
         node.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword))) {
      
      let exportedItems = [];
      if (ts.isExportDeclaration(node) && node.exportClause) {
        if (ts.isNamedExports(node.exportClause)) {
          exportedItems = node.exportClause.elements.map(el => el.name.text);
        }
      } else if (ts.isFunctionDeclaration(node) && node.name) {
        exportedItems.push(node.name.text);
      }
      
      fileData[currentFileIndex].exports = fileData[currentFileIndex].exports.concat(exportedItems);
    }
    
    ts.forEachChild(node, collectImports);
  }
  
  // Process function definitions and calls
  function processNode(node, currentFunction = null) {
    // Function declarations
    if (ts.isFunctionDeclaration(node) && node.name) {
      const functionName = node.name.text;
      const line = sourceFile.getLineAndCharacterOfPosition(node.name.pos).line + 1;
      const isExported = node.modifiers && node.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);
      const isPrivate = functionName.startsWith('_');
      
      // Extract JSDoc comments if any
      let description = '';
      if (node.jsDoc && node.jsDoc.length > 0) {
        description = node.jsDoc[0].comment || '';
      }
      
      // Extract parameters
      const parameters = node.parameters.map(param => {
        return {
          name: param.name.getText(sourceFile),
          type: param.type ? param.type.getText(sourceFile) : 'any'
        };
      });
      
      // Extract return type
      let returnType = 'void';
      if (node.type) {
        returnType = node.type.getText(sourceFile);
      }
      
      allFunctions.push({
        name: functionName,
        filePath: relativePath,
        line,
        isExported,
        isPrivate,
        description,
        parameters,
        returnType,
        functionType: 'declaration',
        length: node.end - node.pos
      });
      
      fileData[currentFileIndex].functionCount++;
      currentFunction = functionName;
      
      // Analyze function responsibilities
      analyzeFunctionResponsibilities(node, sourceFile, functionName, relativePath);
      // Calculate complexity
      calculateComplexity(node, sourceFile, functionName);
    }
    
    // Method declarations
    if (ts.isMethodDeclaration(node) && node.name) {
      const methodName = node.name.getText(sourceFile);
      const line = sourceFile.getLineAndCharacterOfPosition(node.name.pos).line + 1;
      const isPrivate = methodName.startsWith('_');
      
      // Extract parameters
      const parameters = node.parameters.map(param => {
        return {
          name: param.name.getText(sourceFile),
          type: param.type ? param.type.getText(sourceFile) : 'any'
        };
      });
      
      // Extract return type
      let returnType = 'void';
      if (node.type) {
        returnType = node.type.getText(sourceFile);
      }
      
      allFunctions.push({
        name: methodName,
        filePath: relativePath,
        line,
        isExported: false, // Methods are not directly exported
        isPrivate,
        description: '',
        parameters,
        returnType,
        functionType: 'method',
        length: node.end - node.pos
      });
      
      fileData[currentFileIndex].functionCount++;
      currentFunction = methodName;
      
      // Analyze function responsibilities
      analyzeFunctionResponsibilities(node, sourceFile, methodName, relativePath);
      // Calculate complexity
      calculateComplexity(node, sourceFile, methodName);
    }
    
    // Arrow functions
    if (ts.isVariableDeclaration(node) && 
        node.name && 
        node.initializer && 
        ts.isArrowFunction(node.initializer)) {
      const functionName = node.name.getText(sourceFile);
      const line = sourceFile.getLineAndCharacterOfPosition(node.name.pos).line + 1;
      const isExported = false; // We'll check parent nodes later for exports
      const isPrivate = functionName.startsWith('_');
      
      // Extract parameters
      const parameters = node.initializer.parameters.map(param => {
        return {
          name: param.name.getText(sourceFile),
          type: param.type ? param.type.getText(sourceFile) : 'any'
        };
      });
      
      // Extract return type
      let returnType = 'void';
      if (node.initializer.type) {
        returnType = node.initializer.type.getText(sourceFile);
      }
      
      allFunctions.push({
        name: functionName,
        filePath: relativePath,
        line,
        isExported,
        isPrivate,
        description: '',
        parameters,
        returnType,
        functionType: 'arrow',
        length: node.initializer.end - node.initializer.pos
      });
      
      fileData[currentFileIndex].functionCount++;
      currentFunction = functionName;
      
      // Analyze function responsibilities
      analyzeFunctionResponsibilities(node.initializer, sourceFile, functionName, relativePath);
      // Calculate complexity
      calculateComplexity(node.initializer, sourceFile, functionName);
    }
    
    // Function calls
    if (ts.isCallExpression(node) && currentFunction) {
      let calledFunctionName = '';
      
      // Direct calls: functionName()
      if (ts.isIdentifier(node.expression)) {
        calledFunctionName = node.expression.text;
      }
      
      // Property access: object.method()
      if (ts.isPropertyAccessExpression(node.expression)) {
        calledFunctionName = node.expression.name.text;
        
        // Capture the object part for context
        const objectPart = node.expression.expression.getText(sourceFile);
        
        functionCalls.push({
          caller: currentFunction,
          callerFile: relativePath,
          callee: calledFunctionName,
          fullCall: `${objectPart}.${calledFunctionName}`,
          line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1
        });
      }
      
      // Only track direct function calls that are not built-in functions
      if (calledFunctionName && 
          !['log', 'error', 'warn', 'info', 'debug', 'forEach', 'map', 'filter', 'reduce', 'push', 'pop'].includes(calledFunctionName) &&
          !ts.isPropertyAccessExpression(node.expression)) {
          
        functionCalls.push({
          caller: currentFunction,
          callerFile: relativePath,
          callee: calledFunctionName,
          fullCall: calledFunctionName,
          line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1
        });
      }
    }
    
    // Continue traversing with updated current function
    ts.forEachChild(node, n => processNode(n, currentFunction));
  }
  
  // Collect imports and exports
  collectImports(sourceFile);
  
  // Process functions and calls
  processNode(sourceFile);
}

// Walk through directories recursively
function walkDir(dir) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      walkDir(filePath);
    } else if (stat.isFile() && (file.endsWith('.ts') || file.endsWith('.tsx'))) {
      processFile(filePath);
    }
  });
}

// Start the analysis
console.log("Starting codebase analysis...");
walkDir(rootDir);

// Run initial system analyses
detectCircularDependencies();
generateCouplingMatrix();

// Sort files by number of functions (descending)
fileData.sort((a, b) => b.functionCount - a.functionCount);

// Function to run system-level analysis across the entire codebase
function analyzeCodebase() {
  // Generate system-wide metrics
  let systemReport = `# System-Level Analysis\n\n`;
  
  // Circular dependency report
  systemReport += `## Circular Dependencies\n\n`;
  if (circularDependencies.length > 0) {
    circularDependencies.forEach((cycle, index) => {
      systemReport += `### Cycle ${index + 1}\n`;
      systemReport += cycle.join(' â†’ ') + ' â†’ ' + cycle[0] + '\n\n';
    });
  } else {
    systemReport += `No circular dependencies detected! ðŸŽ‰\n\n`;
  }
  
  // Component coupling matrix
  systemReport += `## Component Coupling Matrix\n\n`;
  systemReport += `Higher numbers indicate stronger coupling (more calls between components).\n\n`;
  
  const components = Object.keys(couplingMatrix);
  
  // Table header
  systemReport += `| Component | ${components.join(' | ')} |\n`;
  systemReport += `|-----------|${components.map(() => '---').join('|')}|\n`;
  
  // Table rows
  components.forEach(compA => {
    let row = `| **${compA}** |`;
    
    components.forEach(compB => {
      const coupling = couplingMatrix[compA][compB];
      const value = coupling ? `${coupling.callCount} (${coupling.dependencyStrength})` : '0';
      row += ` ${value} |`;
    });
    
    systemReport += row + '\n';
  });
  
  // Module heat map (most imported modules)
  systemReport += `\n## Most Imported Modules\n\n`;
  
  const sortedModules = Object.entries(moduleHeatMap)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 20);
  
  systemReport += `| Module | Import Count |\n`;
  systemReport += `|--------|-------------|\n`;
  
  sortedModules.forEach(([module, count]) => {
    systemReport += `| ${module} | ${count} |\n`;
  });
  
  // Function complexity ranking across entire codebase
  systemReport += `\n## Top 20 Most Complex Functions\n\n`;
  
  const allComplexity = allFunctions.map(func => ({
    name: func.name || 'anonymous',
    filePath: func.filePath || 'unknown',
    complexity: functionComplexityScores[func.name] || 1,
    length: func.length || 0,
    parameters: (func.parameters && func.parameters.length) || 0
  }))
  .sort((a, b) => b.complexity - a.complexity || b.length - a.length)
  .slice(0, 20);
  
  systemReport += `| Function | File | Complexity | Length | Parameters |\n`;
  systemReport += `|----------|------|------------|--------|------------|\n`;
  
  allComplexity.forEach(func => {
    systemReport += `| \`${func.name}\` | ${func.filePath} | ${func.complexity} | ${func.length} | ${func.parameters} |\n`;
  });
  
  // Bottleneck functions across entire codebase
  systemReport += `\n## Top 20 Global Bottleneck Functions\n\n`;
  
  // Avoid using Sets which could cause errors
  let bottlenecks = [];
  
  try {
    // Create a simple map to track function calls
    const callMap = {};
    
    // Process all function calls safely
    for (const call of functionCalls) {
      if (!call || !call.callee) continue;
      
      const calleeName = String(call.callee);
      if (!callMap[calleeName]) {
        callMap[calleeName] = {
          count: 0,
          uniqueCallers: {}
        };
      }
      
      callMap[calleeName].count++;
      
      // Use an object instead of a Set to track unique callers
      if (call.caller) {
        const callerKey = call.caller + (call.callerFile ? `-${call.callerFile}` : '');
        callMap[calleeName].uniqueCallers[callerKey] = true;
      }
    }
    
    // Convert to array for sorting
    bottlenecks = Object.keys(callMap).map(funcName => {
      const data = callMap[funcName];
      const uniqueCallerCount = Object.keys(data.uniqueCallers).length;
      
      return {
        name: funcName,
        callCount: data.count,
        callerCount: uniqueCallerCount,
        bottleneckScore: data.count * uniqueCallerCount
      };
    })
    .sort((a, b) => b.bottleneckScore - a.bottleneckScore)
    .slice(0, 20);
  } catch (error) {
    console.error("Error analyzing bottlenecks:", error);
  }
  
  // Generate the report section
  systemReport += `| Function | Incoming Calls | Unique Callers | Bottleneck Score |\n`;
  systemReport += `|----------|---------------|---------------|----------------|\n`;
  
  bottlenecks.forEach(func => {
    systemReport += `| \`${func.name}\` | ${func.callCount} | ${func.callerCount} | ${func.bottleneckScore} |\n`;
  });
  
  // Create output directory if it doesn't exist
  const outputDir = './analysis';
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir);
  }
  
  // Write system report
  fs.writeFileSync(`${outputDir}/system_analysis.md`, systemReport);
  
  // Generate HTML visualization of the component coupling
  let couplingVisualizationHtml = `
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>Component Coupling Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
      .chord { opacity: 0.8; }
      .node { font-size: 10px; }
    </style>
  </head>
  <body>
    <h1>Component Coupling Visualization</h1>
    <div id="chord"></div>
    <script>
      // Convert coupling matrix to D3 format
      const components = ${JSON.stringify(components)};
      const matrix = [];
      
      components.forEach(compA => {
        const row = [];
        components.forEach(compB => {
          const coupling = ${JSON.stringify(couplingMatrix)}[compA][compB];
          row.push(coupling ? coupling.callCount : 0);
        });
        matrix.push(row);
      });
      
      // Set up chord diagram
      const width = 700;
      const height = 700;
      const innerRadius = Math.min(width, height) * 0.4;
      const outerRadius = innerRadius * 1.1;
      
      const svg = d3.select("#chord")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", \`translate(\${width / 2}, \${height / 2})\`);
        
      const chord = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending);
        
      const arc = d3.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);
        
      const ribbon = d3.ribbon()
        .radius(innerRadius);
        
      const color = d3.scaleOrdinal()
        .domain(d3.range(components.length))
        .range(d3.schemeCategory10);
        
      const chords = chord(matrix);
      
      svg.append("g")
        .selectAll("path")
        .data(chords)
        .join("path")
        .attr("class", "chord")
        .attr("d", ribbon)
        .attr("fill", d => color(d.source.index))
        .attr("stroke", d => d3.rgb(color(d.source.index)).darker());
        
      const group = svg.append("g")
        .selectAll("g")
        .data(chords.groups)
        .join("g");
        
      group.append("path")
        .attr("d", arc)
        .attr("fill", d => color(d.index))
        .attr("stroke", d => d3.rgb(color(d.index)).darker());
        
      group.append("text")
        .each(d => { d.angle = (d.startAngle + d.endAngle) / 2; })
        .attr("dy", ".35em")
        .attr("transform", d => \`
          rotate(\${(d.angle * 180 / Math.PI - 90)})
          translate(\${outerRadius + 10})
          \${d.angle > Math.PI ? "rotate(180)" : ""}
        \`)
        .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
        .text(d => components[d.index]);
    </script>
  </body>
  </html>
  `;
  
  fs.writeFileSync(`${outputDir}/component_coupling.html`, couplingVisualizationHtml);
  
  console.log(`System-level analysis complete! Results saved to:`);
  console.log(`  - ${outputDir}/system_analysis.md`);
  console.log(`  - ${outputDir}/component_coupling.html`);
}

// Display top files for selection
console.log("\nTop 15 files by function count:");
fileData.slice(0, 15).forEach((file, index) => {
  console.log(`${index + 1}. ${file.path} (${file.functionCount} functions, ${file.lineCount} lines)`);
});

// Ask user to select analysis option
rl.question('\nSelect an option:\n1. Analyze a specific file\n2. Run system-level analysis\nChoice: ', (answer) => {
  if (answer === '1') {
    // Show file list and analyze a specific file
    rl.question('\nEnter the number of the file to analyze (1-15): ', (fileAnswer) => {
      const fileIndex = parseInt(fileAnswer) - 1;
      if (fileIndex >= 0 && fileIndex < 15) {
        analyzeFile(fileIndex);
      } else {
        console.log("Invalid selection. Please run the script again.");
        rl.close();
      }
    });
  } else if (answer === '2') {
    // Run system-level analysis
    analyzeCodebase();
    rl.close();
  } else {
    console.log("Invalid selection. Please run the script again.");
    rl.close();
  }
});

// Function to analyze a specific file
function analyzeFile(fileIndex) {
  const selectedFile = fileData[fileIndex];
  
  if (!selectedFile) {
    console.log("Invalid file selection.");
    rl.close();
    return;
  }
  
  const filePath = selectedFile.path;
  console.log(`\nAnalyzing: ${filePath}\n`);
  
  // Create output directory if it doesn't exist
  const outputDir = './analysis';
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir);
  }
  
  // Generate file report
  let report = `# File Analysis: ${filePath}\n\n`;
  
  // Basic stats
  report += `## Overview\n\n`;
  report += `- **Line Count:** ${selectedFile.lineCount}\n`;
  report += `- **Function Count:** ${selectedFile.functionCount}\n`;
  
  // Imports
  report += `- **Imports:** ${selectedFile.imports.length} modules\n`;
  selectedFile.imports.forEach(imp => {
    report += `  - From \`${imp.path}\`: ${imp.items.length ? imp.items.join(', ') : '(default import)'}\n`;
  });
  
  // Exports
  report += `- **Exports:** ${selectedFile.exports.length} items\n`;
  if (selectedFile.exports.length) {
    report += `  - ${selectedFile.exports.join(', ')}\n`;
  }
  
  // Functions defined in this file
  const fileFunctions = allFunctions.filter(f => f.filePath === filePath);
  report += `\n## Functions Defined (${fileFunctions.length})\n\n`;
  report += `| Line | Function | Type | Privacy | Parameters | Return Type | Length | Complexity |\n`;
  report += `|------|----------|------|---------|------------|-------------|--------|------------|\n`;
  
  fileFunctions.sort((a, b) => a.line - b.line);
  fileFunctions.forEach(func => {
    const paramStr = func.parameters.map(p => `${p.name}: ${p.type}`).join(', ');
    const complexity = functionComplexityScores[func.name] || 1;
    report += `| ${func.line} | \`${func.name}\` | ${func.functionType} | ${func.isPrivate ? 'private' : 'public'} | ${paramStr || 'none'} | ${func.returnType} | ${func.length} | ${complexity} |\n`;
  });
  
  // Function responsibility analysis
  report += `\n## Function Responsibility Analysis\n\n`;
  
  const fileResponsibilities = componentResponsibilities[filePath] || {};
  
  report += `| Function | State Mgmt | UI Rendering | Data Fetching | Event Handling | Service Init | Error Handling | Timer Mgmt | Responsibility Spread |\n`;
  report += `|----------|------------|--------------|---------------|----------------|--------------|----------------|-----------|----------------------|\n`;
  
  Object.keys(fileResponsibilities).forEach(funcName => {
    const resp = fileResponsibilities[funcName] || {};
    report += `| \`${funcName}\` | ${resp.stateManagement || 0} | ${resp.uiRendering || 0} | ${resp.dataFetching || 0} | ${resp.eventHandling || 0} | ${resp.serviceInitialization || 0} | ${resp.errorHandling || 0} | ${resp.timerManagement || 0} | ${resp.responsibilitySpread || 0} |\n`;
  });
  
  // Outgoing calls - functions this file calls
  const outgoingCalls = functionCalls.filter(call => call.callerFile === filePath);
  const uniqueOutgoing = [...new Set(outgoingCalls.map(call => call.callee))];
  
  report += `\n## Outgoing Calls (${uniqueOutgoing.length} unique functions)\n\n`;
  
  // Group by caller
  const callerGroups = {};
  outgoingCalls.forEach(call => {
    if (!callerGroups[call.caller]) {
      callerGroups[call.caller] = [];
    }
    callerGroups[call.caller].push(call);
  });
  
  Object.keys(callerGroups).forEach(caller => {
    report += `### From \`${caller}\`\n\n`;
    
    // Find unique callees for this caller
    const uniqueCallees = {};
    callerGroups[caller].forEach(call => {
      if (!uniqueCallees[call.callee]) {
        uniqueCallees[call.callee] = [];
      }
      // Make sure we're pushing to an array
      if (Array.isArray(uniqueCallees[call.callee])) {
        uniqueCallees[call.callee].push(call.line);
      }
    });
    
    report += `| Called Function | Call Count | Line Numbers |\n`;
    report += `|----------------|------------|-------------|\n`;
    
    Object.keys(uniqueCallees).forEach(callee => {
      if (Array.isArray(uniqueCallees[callee])) {
        report += `| \`${callee}\` | ${uniqueCallees[callee].length} | ${uniqueCallees[callee].join(', ')} |\n`;
      } else {
        // Fallback in case it's not an array
        report += `| \`${callee}\` | 1 | unknown |\n`;
      }
    });
    
    report += `\n`;
  });
  
  // Incoming calls - functions from other files that call functions in this file
  const incomingCalls = functionCalls.filter(call => {
    // Find if the callee is defined in this file
    return allFunctions.some(f => 
      f.filePath === filePath && f.name === call.callee
    ) && call.callerFile !== filePath; // Exclude self-calls
  });
  
  report += `\n## Incoming Calls (${incomingCalls.length} calls from other files)\n\n`;
  
  if (incomingCalls.length > 0) {
    // Group by target function
    const targetGroups = {};
    incomingCalls.forEach(call => {
      if (!targetGroups[call.callee]) {
        targetGroups[call.callee] = [];
      }
      targetGroups[call.callee].push(call);
    });
    
    Object.keys(targetGroups).forEach(target => {
      report += `### To \`${target}\`\n\n`;
      report += `| Caller | File | Line |\n`;
      report += `