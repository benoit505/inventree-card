{"version":3,"file":"ConditionalEffectsEngine-b87c8e6d.js","sources":["../src/core/ConditionalEffectsEngine.ts"],"sourcesContent":["import { RootState } from '../store';\nimport { ConditionalPartEffect, ParameterDetail, InventreeItem, ParameterOperator, ParameterActionType, ProcessedCondition, ConditionRuleDefinition } from '../types';\nimport { selectProcessedConditions as selectProcessedConditionsFromLogic } from '../store/slices/conditionalLogicSlice';\nimport {\n    selectGenericHaEntityState,\n    selectGenericHaEntityActualState,\n    selectGenericHaEntityAttribute\n} from '../store/slices/genericHaStateSlice';\nimport { Logger } from '../utils/logger';\nimport { setConditionalPartEffectsBatch } from '../store/slices/parametersSlice';\nimport { AppDispatch } from '../store'; // Assuming AppDispatch is exported from your store\n\nconst logger = Logger.getInstance();\n\nexport class ConditionalEffectsEngine {\n    private dispatch: AppDispatch;\n    private getState: () => RootState;\n\n    constructor(dispatch: AppDispatch, getState: () => RootState) {\n        this.dispatch = dispatch;\n        this.getState = getState;\n        logger.log('ConditionalEffectsEngine', 'Engine initialized.');\n    }\n\n    public evaluateAndApplyEffects(): void {\n        const state = this.getState();\n        const conditions = selectProcessedConditionsFromLogic(state);\n        const allParametersByPartId = state.parameters.parameterValues;\n        const allPartsById = state.parts.partsById;\n\n        logger.log('[ConditionalEffectsEngine]', 'evaluateAndApplyEffects - START.', {\n            level: 'debug',\n            processedConditionsCount: conditions.length,\n            parameterValuesKeys: Object.keys(allParametersByPartId).length\n        });\n\n        if (!conditions || conditions.length === 0) {\n            logger.log('ConditionalEffectsEngine', 'No processed conditions to evaluate. Clearing existing effects.');\n            this.dispatch(setConditionalPartEffectsBatch({}));\n            return;\n        }\n\n        const newEffects: Record<number, ConditionalPartEffect> = {};\n\n        const mergeEffect = (partId: number, effect: Partial<ConditionalPartEffect>) => {\n            if (!newEffects[partId]) {\n                newEffects[partId] = {};\n            }\n            newEffects[partId] = { ...newEffects[partId], ...effect };\n        };\n\n        for (const processedCond of conditions) { // Renamed to avoid confusion with 'condition' variable inside loop\n            let conditionResult = false;\n            const rule = processedCond.originalRule; // Access the original rule definition\n\n            let targetPartPks: number[] = [];\n            if (rule.targetPartIds === '*') {\n                targetPartPks = Object.keys(allPartsById).map((id: string) => parseInt(id, 10)).filter(id => !isNaN(id));\n            } else if (Array.isArray(rule.targetPartIds)) {\n                targetPartPks = rule.targetPartIds.filter((id: any) => typeof id === 'number' && !isNaN(id));\n            }\n\n            let valueToEvaluateAgainst: any;\n            let sourceDescription = `Condition ID: ${processedCond.id}, Source: ${rule.parameter}`;\n\n            switch (processedCond.sourceType) {\n                case 'inventree_parameter':\n                    if (processedCond.partId !== undefined && processedCond.parameterName) {\n                        const partParams = allParametersByPartId[processedCond.partId];\n                        valueToEvaluateAgainst = partParams?.[processedCond.parameterName]?.data;\n                        sourceDescription += ` (Part PK: ${processedCond.partId}, Param: ${processedCond.parameterName})`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing partId or parameterName for inventree_parameter type.`, { processedCond });\n                    }\n                    break;\n                case 'inventree_attribute':\n                    if (processedCond.partId !== undefined && processedCond.attributeName) {\n                        const partData = allPartsById[processedCond.partId];\n                        valueToEvaluateAgainst = partData?.[processedCond.attributeName];\n                        sourceDescription += ` (Part PK: ${processedCond.partId}, Attribute: ${processedCond.attributeName})`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing partId or attributeName for inventree_attribute type.`, { processedCond });\n                    }\n                    break;\n                case 'ha_entity_state':\n                    if (processedCond.entityId) {\n                        valueToEvaluateAgainst = selectGenericHaEntityActualState(state, processedCond.entityId);\n                        sourceDescription += ` (Entity: ${processedCond.entityId}, State)`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing entityId for ha_entity_state type.`, { processedCond });\n                    }\n                    break;\n                case 'ha_entity_attribute':\n                    if (processedCond.entityId && processedCond.haAttributeName) {\n                        valueToEvaluateAgainst = selectGenericHaEntityAttribute(state, processedCond.entityId, processedCond.haAttributeName);\n                        sourceDescription += ` (Entity: ${processedCond.entityId}, Attribute: ${processedCond.haAttributeName})`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing entityId or haAttributeName for ha_entity_attribute type.`, { processedCond });\n                    }\n                    break;\n                case 'unknown':\n                default:\n                    logger.warn('ConditionalEffectsEngine', `Unhandled or unknown sourceType: ${processedCond.sourceType}`, { processedCond });\n                    valueToEvaluateAgainst = undefined;\n                    break;\n            }\n            \n            if (valueToEvaluateAgainst === undefined || valueToEvaluateAgainst === null) {\n                switch (rule.operator) {\n                    case 'exists': conditionResult = false; break;\n                    case 'is_empty': conditionResult = true; break;\n                    default:\n                        if (rule.operator === 'equals' && (rule.value === null || rule.value === '')) {\n                            conditionResult = true;\n                        } else if (rule.operator === 'not_equals' && (rule.value !== null && rule.value !== '')) {\n                            conditionResult = true;\n                        } else {\n                            conditionResult = false;\n                        }\n                        break;\n                }\n            } else {\n                switch (rule.operator) {\n                    case 'equals': conditionResult = String(valueToEvaluateAgainst) === String(rule.value); break;\n                    case 'not_equals': conditionResult = String(valueToEvaluateAgainst) !== String(rule.value); break;\n                    case 'contains': conditionResult = String(valueToEvaluateAgainst).includes(String(rule.value)); break;\n                    case 'exists': conditionResult = String(valueToEvaluateAgainst).trim() !== ''; break; \n                    case 'is_empty': conditionResult = String(valueToEvaluateAgainst).trim() === ''; break; \n                    case 'greater_than':\n                        const numParamValGt = parseFloat(String(valueToEvaluateAgainst));\n                        const numValToCompareGt = parseFloat(String(rule.value));\n                        conditionResult = !isNaN(numParamValGt) && !isNaN(numValToCompareGt) && numParamValGt > numValToCompareGt;\n                        break;\n                    case 'less_than':\n                        const numParamValLt = parseFloat(String(valueToEvaluateAgainst));\n                        const numValToCompareLt = parseFloat(String(rule.value));\n                        conditionResult = !isNaN(numParamValLt) && !isNaN(numValToCompareLt) && numParamValLt < numValToCompareLt;\n                        break;\n                    default:\n                        logger.warn('ConditionalEffectsEngine', `Unknown operator: ${rule.operator}`, { rule, valueToEvaluateAgainst });\n                        conditionResult = false;\n                }\n            }\n\n            if (conditionResult) {\n                logger.log('ConditionalEffectsEngine', `Condition MET: ${sourceDescription}`, {\n                    level: 'debug',\n                    conditionId: processedCond.id,\n                    originalRule: rule,\n                    valueEvaluated: valueToEvaluateAgainst,\n                    targetPartPks\n                });\n\n                for (const pk of targetPartPks) {\n                    let effectToApply: Partial<ConditionalPartEffect> = {};\n                    switch (rule.action) {\n                        case 'filter': effectToApply.isVisible = rule.action_value === 'show'; break;\n                        case 'highlight': effectToApply.highlight = rule.action_value; break;\n                        case 'text_color': effectToApply.textColor = rule.action_value; break;\n                        case 'border': effectToApply.border = rule.action_value; break;\n                        case 'icon': effectToApply.icon = rule.action_value; break;\n                        case 'badge': effectToApply.badge = rule.action_value; break;\n                        case 'priority': effectToApply.priority = rule.action_value; break;\n                        case 'sort':\n                        case 'show_section':\n                            logger.log('ConditionalEffectsEngine', `Action type '${rule.action}' requires specific handling not yet implemented.`, { rule });\n                            break;\n                        default: logger.warn('ConditionalEffectsEngine', `Unknown action type: ${rule.action}`, { rule });\n                    }\n\n                    if (Object.keys(effectToApply).length > 0) {\n                        mergeEffect(pk, effectToApply);\n                    } else {\n                         logger.warn('[ConditionalEffectsEngine]', 'effectToApply is empty, no effect merged.', {\n                            level: 'debug',\n                            conditionId: processedCond.id, action: rule.action, actionValue: rule.action_value, targetPartPks\n                        });\n                    }\n                }\n            } else {\n                 logger.log('ConditionalEffectsEngine', 'Condition NOT MET', {\n                    level: 'silly', \n                    conditionId: processedCond.id, originalRuleParameter: rule.parameter, evaluatedValue: valueToEvaluateAgainst, comparedTo: rule.value, operator: rule.operator\n                });\n            }\n        }\n\n        logger.log('[ConditionalEffectsEngine]', 'Final newEffects before dispatching setConditionalPartEffectsBatch', {level: 'debug', newEffects });\n        this.dispatch(setConditionalPartEffectsBatch(newEffects));\n        logger.log('ConditionalEffectsEngine', 'Finished evaluating conditions and dispatched effects batch.', { newEffectsCount: Object.keys(newEffects).length });\n    }\n}\n\n// Example of how it might be instantiated and used (e.g., in a thunk or middleware)\n//\n// import { store } from '../store'; // Or get dispatch/getState from thunkAPI\n//\n// const effectsEngine = new ConditionalEffectsEngine(store.dispatch, store.getState);\n// effectsEngine.evaluateAndApplyEffects(); "],"names":["logger","Logger","getInstance","ConditionalEffectsEngine","constructor","dispatch","getState","this","log","evaluateAndApplyEffects","state","conditions","selectProcessedConditionsFromLogic","allParametersByPartId","parameters","parameterValues","allPartsById","parts","partsById","level","processedConditionsCount","length","parameterValuesKeys","Object","keys","setConditionalPartEffectsBatch","newEffects","processedCond","conditionResult","rule","originalRule","valueToEvaluateAgainst","targetPartPks","targetPartIds","map","id","parseInt","filter","isNaN","Array","isArray","sourceDescription","parameter","sourceType","undefined","partId","parameterName","partParams","_a","data","warn","attributeName","partData","entityId","selectGenericHaEntityActualState","haAttributeName","selectGenericHaEntityAttribute","operator","value","String","includes","trim","numParamValGt","parseFloat","numValToCompareGt","numParamValLt","numValToCompareLt","conditionId","valueEvaluated","pk","effectToApply","action","isVisible","action_value","highlight","textColor","border","icon","badge","priority","effect","assign","actionValue","originalRuleParameter","evaluatedValue","comparedTo","newEffectsCount"],"mappings":"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"}