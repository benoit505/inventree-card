{"version":3,"file":"ConditionalEffectsEngine-c6d7d40b.js","sources":["../src/core/ConditionalEffectsEngine.ts"],"sourcesContent":["import { RootState } from '../store';\nimport { ParameterDetail, InventreeItem, ParameterOperator, ParameterActionType, ProcessedCondition, ConditionRuleDefinition, EffectDefinition } from '../types';\nimport { VisualEffect } from '../store/slices/visualEffectsSlice';\nimport { selectProcessedConditions as selectProcessedConditionsFromLogic } from '../store/slices/conditionalLogicSlice';\nimport {\n    selectGenericHaEntityState,\n    selectGenericHaEntityActualState,\n    selectGenericHaEntityAttribute\n} from '../store/slices/genericHaStateSlice';\nimport { Logger } from '../utils/logger';\nimport { setVisualEffectsBatch } from '../store/slices/visualEffectsSlice';\nimport { AppDispatch } from '../store';\nimport { inventreeApi } from '../store/apis/inventreeApi';\n\nconst logger = Logger.getInstance();\n\n// Helper function to map styleProperty from EffectDefinition to VisualEffect keys\nconst mapStylePropertyToVisualEffectKey = (styleProperty: string): keyof VisualEffect | null => {\n    const lowerCaseProp = styleProperty.toLowerCase();\n    switch (lowerCaseProp) {\n        case 'highlight':\n        case 'backgroundcolor':\n            return 'highlight';\n        case 'textcolor':\n        case 'color':\n            return 'textColor';\n        case 'border':\n            return 'border';\n        case 'icon':\n            return 'icon';\n        case 'badge':\n            return 'badge';\n        case 'opacity':\n            return 'opacity';\n        case 'priority':\n            return 'priority';\n        // Add other direct mappings here if VisualEffect has more specific keys\n        // For example, if customClasses becomes a direct string property:\n        // case 'customclasses':\n        // return 'customClasses';\n        default:\n            // Check if it's a direct match to a VisualEffect key (for less common ones)\n            const directMatch = styleProperty as keyof VisualEffect;\n            const sampleVisualEffect: VisualEffect = { isVisible: true }; // Dummy object to check keys\n            if (Object.keys(sampleVisualEffect).includes(directMatch)) {\n                return directMatch;\n            }\n            return null;\n    }\n};\n\nexport class ConditionalEffectsEngine {\n    private dispatch: AppDispatch;\n    private getState: () => RootState;\n\n    constructor(dispatch: AppDispatch, getState: () => RootState) {\n        this.dispatch = dispatch;\n        this.getState = getState;\n        logger.log('ConditionalEffectsEngine', 'Engine initialized.');\n    }\n\n    public evaluateAndApplyEffects(): void {\n        const state = this.getState();\n        const conditions = selectProcessedConditionsFromLogic(state);\n        const allParametersByPartId = state.parameters.parameterValues;\n        const allPartsById = state.parts.partsById;\n\n        // TEMP LOG 1: Log processedConditions\n        // console.log('[TEMP LOG CEE] Initial processedConditions:', JSON.parse(JSON.stringify(conditions || [])));\n\n        logger.log('[ConditionalEffectsEngine]', 'evaluateAndApplyEffects - START.', {\n            level: 'debug',\n            processedConditionsCount: conditions.length,\n            parameterValuesKeys: Object.keys(allParametersByPartId).length\n        });\n\n        if (!conditions || conditions.length === 0) {\n            logger.log('ConditionalEffectsEngine', 'No processed conditions to evaluate. Clearing existing effects.');\n            this.dispatch(setVisualEffectsBatch({}));\n            return;\n        }\n\n        const newEffects: Record<number, VisualEffect> = {};\n\n        const mergeEffect = (partId: number, effect: Partial<VisualEffect>) => {\n            if (!newEffects[partId]) {\n                newEffects[partId] = {} as VisualEffect;\n            }\n            newEffects[partId] = { ...newEffects[partId], ...effect };\n        };\n\n        for (const processedCond of conditions) {\n            let conditionResult = false;\n            const rule = processedCond.originalRule;\n\n            let targetPartPks: number[] = [];\n            if (rule.targetPartIds === '*') {\n                targetPartPks = Object.keys(allPartsById).map((id: string) => parseInt(id, 10)).filter(id => !isNaN(id));\n            } else if (Array.isArray(rule.targetPartIds)) {\n                targetPartPks = rule.targetPartIds.filter((id: any) => typeof id === 'number' && !isNaN(id));\n            }\n\n            let valueToEvaluateAgainst: any;\n            let sourceDescription = `Condition ID: ${processedCond.id}, Source: ${rule.parameter}`;\n\n            switch (processedCond.sourceType) {\n                case 'inventree_parameter':\n                    if (processedCond.partId !== undefined && processedCond.parameterName) {\n                        const selectGetPartParametersQuery = inventreeApi.endpoints.getPartParameters.select(processedCond.partId);\n                        const queryResult = selectGetPartParametersQuery(state);\n\n                        if (queryResult?.status === 'fulfilled' && queryResult.data) {\n                            const parameters: ParameterDetail[] = queryResult.data;\n                            const targetParameter = parameters.find(p => p.template_detail?.name === processedCond.parameterName);\n                            valueToEvaluateAgainst = targetParameter?.data;\n                            logger.log('[ConditionalEffectsEngine]', `Read from RTK Query: Part ${processedCond.partId}, Param ${processedCond.parameterName}, Value: ${valueToEvaluateAgainst}`, {level: 'debug'});\n                        } else {\n                            logger.warn('ConditionalEffectsEngine', `Parameters for part ${processedCond.partId} not fulfilled in RTK Query cache. Status: ${queryResult?.status}. Param: ${processedCond.parameterName}`, { queryStatus: queryResult?.status });\n                            valueToEvaluateAgainst = undefined; \n                        }\n                        sourceDescription += ` (Part PK: ${processedCond.partId}, Param: ${processedCond.parameterName})`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing partId or parameterName for inventree_parameter type.`, { processedCond });\n                    }\n                    break;\n                case 'inventree_attribute':\n                    if (processedCond.partId !== undefined && processedCond.attributeName) {\n                        const partData = allPartsById[processedCond.partId];\n                        valueToEvaluateAgainst = partData?.[processedCond.attributeName];\n                        sourceDescription += ` (Part PK: ${processedCond.partId}, Attribute: ${processedCond.attributeName})`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing partId or attributeName for inventree_attribute type.`, { processedCond });\n                    }\n                    break;\n                case 'ha_entity_state':\n                    if (processedCond.entityId) {\n                        // TEMP LOG 2a: Log entityId for ha_entity_state\n                        // console.log(`[TEMP LOG CEE] ha_entity_state: processing entityId: ${processedCond.entityId}`);\n                        valueToEvaluateAgainst = selectGenericHaEntityActualState(state, processedCond.entityId);\n                        // TEMP LOG 2b: Log valueToEvaluateAgainst for ha_entity_state\n                        // console.log(`[TEMP LOG CEE] ha_entity_state: valueToEvaluateAgainst for ${processedCond.entityId}:`, valueToEvaluateAgainst);\n                        sourceDescription += ` (Entity: ${processedCond.entityId}, State)`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing entityId for ha_entity_state type.`, { processedCond });\n                    }\n                    break;\n                case 'ha_entity_attribute':\n                    if (processedCond.entityId && processedCond.haAttributeName) {\n                        valueToEvaluateAgainst = selectGenericHaEntityAttribute(state, processedCond.entityId, processedCond.haAttributeName);\n                        sourceDescription += ` (Entity: ${processedCond.entityId}, Attribute: ${processedCond.haAttributeName})`;\n                    } else {\n                        logger.warn('ConditionalEffectsEngine', `Missing entityId or haAttributeName for ha_entity_attribute type.`, { processedCond });\n                    }\n                    break;\n                case 'unknown':\n                default:\n                    logger.warn('ConditionalEffectsEngine', `Unhandled or unknown sourceType: ${processedCond.sourceType}`, { processedCond });\n                    valueToEvaluateAgainst = undefined;\n                    break;\n            }\n            \n            // TEMP LOG 3: Log before operator switch\n            // console.log(`[TEMP LOG CEE] Before operator switch for rule on '${rule.parameter}': valueToEvaluateAgainst:`, valueToEvaluateAgainst, `operator: ${rule.operator}, rule.value:`, rule.value);\n\n            if (valueToEvaluateAgainst === undefined || valueToEvaluateAgainst === null) {\n                switch (rule.operator) {\n                    case 'exists': conditionResult = false; break;\n                    case 'is_empty': conditionResult = true; break;\n                    default:\n                        if (rule.operator === 'equals' && (rule.value === null || rule.value === '')) {\n                            conditionResult = true;\n                        } else if (rule.operator === 'not_equals' && (rule.value !== null && rule.value !== '')) {\n                            conditionResult = true;\n                        } else {\n                            conditionResult = false;\n                        }\n                        break;\n                }\n            } else {\n                // Normalize the operator before the switch\n                let normalizedOperator: ParameterOperator = rule.operator; // Initially assume it might be a valid ParameterOperator string literal\n\n                // Check if rule.operator is a symbol and needs normalization\n                // Cast to string for the symbolic check, as rule.operator is typed ParameterOperator\n                const currentOperatorSymbol = String(rule.operator);\n                switch (currentOperatorSymbol) { \n                    case '=': \n                        normalizedOperator = 'equals'; \n                        break;\n                    case '!=': \n                        normalizedOperator = 'not_equals'; \n                        break;\n                    case '>': \n                        normalizedOperator = 'greater_than'; \n                        break;\n                    case '<': \n                        normalizedOperator = 'less_than'; \n                        break;\n                    // If rule.operator was already 'equals', 'contains', etc., it will pass through here\n                    // and be assigned to normalizedOperator correctly in the initial declaration. \n                    // Or, if it was a symbol not mapped above, it remains as is from initial assignment.\n                }\n\n                // If after potential normalization, it's still not a valid ParameterOperator type\n                // (e.g. a symbol we didn't map, or an invalid string from the start),\n                // we might need a final check or the switch default will catch it.\n                // For now, the switch on normalizedOperator will ensure type safety for its cases.\n\n                switch (normalizedOperator) { // Switch on the normalized operator\n                    case 'equals': \n                        const valStr = String(valueToEvaluateAgainst);\n                        const ruleValStr = String(rule.value);\n                        conditionResult = valStr === ruleValStr;\n                        // console.log(`[TEMP LOG CEE] 'equals' operator: (Normalized from '${rule.operator}') '${valStr}' === '${ruleValStr}' -> ${conditionResult}`);\n                        break;\n                    case 'not_equals': \n                        conditionResult = String(valueToEvaluateAgainst) !== String(rule.value); \n                        // console.log(`[TEMP LOG CEE] 'not_equals' operator: (Normalized from '${rule.operator}') '${String(valueToEvaluateAgainst)}' !== '${String(rule.value)}' -> ${conditionResult}`);\n                        break;\n                    case 'contains': \n                        conditionResult = String(valueToEvaluateAgainst).includes(String(rule.value)); \n                        // console.log(`[TEMP LOG CEE] 'contains' operator: (Normalized from '${rule.operator}') '${String(valueToEvaluateAgainst)}'.includes('${String(rule.value)}') -> ${conditionResult}`);\n                        break;\n                    case 'exists': \n                        conditionResult = String(valueToEvaluateAgainst).trim() !== ''; \n                        // console.log(`[TEMP LOG CEE] 'exists' operator: (Normalized from '${rule.operator}') '${String(valueToEvaluateAgainst)}'.trim() !== '' -> ${conditionResult}`);\n                        break; \n                    case 'is_empty': \n                        conditionResult = String(valueToEvaluateAgainst).trim() === ''; \n                        // console.log(`[TEMP LOG CEE] 'is_empty' operator: (Normalized from '${rule.operator}') '${String(valueToEvaluateAgainst)}'.trim() === '' -> ${conditionResult}`);\n                        break; \n                    case 'greater_than':\n                        const numParamValGt = parseFloat(String(valueToEvaluateAgainst));\n                        const numValToCompareGt = parseFloat(String(rule.value));\n                        conditionResult = !isNaN(numParamValGt) && !isNaN(numValToCompareGt) && numParamValGt > numValToCompareGt;\n                        // console.log(`[TEMP LOG CEE] 'greater_than' operator: (Normalized from '${rule.operator}') ${numParamValGt} > ${numValToCompareGt} -> ${conditionResult}`);\n                        break;\n                    case 'less_than':\n                        const numParamValLt = parseFloat(String(valueToEvaluateAgainst));\n                        const numValToCompareLt = parseFloat(String(rule.value));\n                        conditionResult = !isNaN(numParamValLt) && !isNaN(numValToCompareLt) && numParamValLt < numValToCompareLt;\n                        // console.log(`[TEMP LOG CEE] 'less_than' operator: (Normalized from '${rule.operator}') ${numParamValLt} < ${numValToCompareLt} -> ${conditionResult}`);\n                        break;\n                    default:\n                        // This default case should ideally not be reached if all operators are handled/normalized\n                        logger.warn('ConditionalEffectsEngine', `Unknown or unnormalized operator: ${normalizedOperator} (original: ${rule.operator})`, { rule, valueToEvaluateAgainst });\n                        conditionResult = false;\n                }\n            }\n\n            if (conditionResult) {\n                // TEMP LOG 5a: Log condition MET\n                // console.log(`[TEMP LOG CEE] Condition MET for rule on '${rule.parameter}'`, { rule_id: processedCond.id, value_evaluated: valueToEvaluateAgainst, targetPartPks });\n\n                logger.log('ConditionalEffectsEngine', `Condition MET: ${sourceDescription}`, {\n                    level: 'debug',\n                    conditionId: processedCond.id,\n                    originalRule: rule,\n                    valueEvaluated: valueToEvaluateAgainst,\n                    targetPartPks\n                });\n\n                if (processedCond.effects && Array.isArray(processedCond.effects)) {\n                    for (const effectDef of processedCond.effects) {\n                        // console.log(`[TEMP LOG CEE] Processing effectDef:`, JSON.parse(JSON.stringify(effectDef)));\n                        let effectToApply: Partial<VisualEffect> = {};\n                        let currentTargetPartPks: number[] = [];\n\n                        // Log the effectDef being processed\n                        logger.log('CEE_EFFECT_DEBUG', 'Processing effectDef:', { data: effectDef });\n\n                        // Determine target part PKs for this specific effect\n                        if (effectDef.targetPartPks) {\n                            if (typeof effectDef.targetPartPks === 'string') {\n                                if (effectDef.targetPartPks.toLowerCase() === 'all_loaded') {\n                                    currentTargetPartPks = targetPartPks;\n                                } else {\n                                    // Assuming comma-separated string of PKs\n                                    currentTargetPartPks = effectDef.targetPartPks.split(',').map(pk => parseInt(pk.trim(), 10)).filter(pk => !isNaN(pk));\n                                }\n                            } else if (Array.isArray(effectDef.targetPartPks)) {\n                                currentTargetPartPks = effectDef.targetPartPks;\n                            }\n                        } else if (targetPartPks && targetPartPks.length > 0) {\n                            // Fallback to rule-level targetPartPks if effect-specific one is not defined\n                            currentTargetPartPks = targetPartPks;\n                        } else if (processedCond.partId !== undefined) { // Check if partId is defined\n                            // Fallback to the partId from the condition if it's a part-specific condition\n                            currentTargetPartPks = [processedCond.partId];\n                        }\n\n                        // Log resolved currentTargetPartPks\n                        logger.log('CEE_EFFECT_DEBUG', 'Resolved currentTargetPartPks:', { data: currentTargetPartPks });\n\n                        if (currentTargetPartPks.length === 0 && (effectDef.type === 'set_style' || effectDef.type === 'set_visibility')) {\n                            logger.warn('CEE', `No target part PKs resolved for effect type '${effectDef.type}' and no fallback. Effect for rule '${rule.name || processedCond.id}' might not apply as expected. Effect ID: ${effectDef.id}`);\n                        }\n\n                        switch (effectDef.type) {\n                            case 'set_visibility':\n                                if (typeof effectDef.isVisible === 'boolean') {\n                                    effectToApply.isVisible = effectDef.isVisible;\n                                }\n                                break;\n                            case 'set_style':\n                                if (effectDef.styleProperty && effectDef.styleValue !== undefined) {\n                                    // Map editor-friendly styleProperty to VisualEffect keys\n                                    const visualEffectKey = mapStylePropertyToVisualEffectKey(effectDef.styleProperty); // Removed cast\n                                    if (visualEffectKey) {\n                                        // Special handling for opacity as it needs to be a number\n                                        if (visualEffectKey === 'opacity') {\n                                            const opacityVal = parseFloat(effectDef.styleValue);\n                                            if (!isNaN(opacityVal)) {\n                                                (effectToApply as any)[visualEffectKey] = opacityVal;\n                                            } else {\n                                                logger.warn('CEE', `Invalid opacity value: ${effectDef.styleValue} for effect ID: ${effectDef.id}. Must be a number.`);\n                                            }\n                                        } else {\n                                            (effectToApply as any)[visualEffectKey] = effectDef.styleValue;\n                                        }\n                                    } else {\n                                        logger.warn('CEE', `Unknown styleProperty: ${effectDef.styleProperty} in effect ID: ${effectDef.id}`);\n                                    }\n                                }\n                                break;\n                            default:\n                                logger.warn('ConditionalEffectsEngine', `Unknown effect type: ${effectDef.type}`, { effectDef });\n                        }\n\n                        // console.log(`[TEMP LOG CEE] Constructed effectToApply:`, JSON.parse(JSON.stringify(effectToApply)), `for targetPartPks:`, targetPartPks);\n                        if (Object.keys(effectToApply).length > 0 && currentTargetPartPks.length > 0) {\n                            // Log effectToApply and currentTargetPartPks before mergeEffect\n                            logger.log('CEE_EFFECT_DEBUG', 'Applying effect:', { data: { effectToApply, pks: currentTargetPartPks } });\n                            for (const pk of currentTargetPartPks) {\n                                mergeEffect(pk, effectToApply);\n                            }\n                        } else {\n                            logger.warn('[ConditionalEffectsEngine]', 'effectToApply was empty for an effectDef, no effect merged.', {\n                                level: 'debug',\n                                conditionId: processedCond.id,\n                                effectDef,\n                                targetPartPks\n                            });\n                        }\n                    }\n                } else {\n                     logger.warn('[ConditionalEffectsEngine]', 'Condition met, but processedCond.effects is missing or not an array.', {\n                        level: 'debug',\n                        conditionId: processedCond.id,\n                        originalRule: rule\n                    });\n                }\n            } else {\n                 logger.log('ConditionalEffectsEngine', 'Condition NOT MET', {\n                    level: 'silly', \n                    conditionId: processedCond.id, originalRuleParameter: rule.parameter, evaluatedValue: valueToEvaluateAgainst, comparedTo: rule.value, operator: rule.operator\n                });\n            }\n        }\n\n        // TEMP LOG 6: Log final newEffects\n        // console.log('[TEMP LOG CEE] Final newEffects before dispatch:', JSON.parse(JSON.stringify(newEffects)));\n\n        logger.log('[ConditionalEffectsEngine]', 'Final newEffects before dispatching setVisualEffectsBatch', {level: 'debug', newEffects: newEffects });\n        this.dispatch(setVisualEffectsBatch(newEffects));\n        logger.log('ConditionalEffectsEngine', 'Finished evaluating conditions and dispatched effects batch.', { newEffectsCount: Object.keys(newEffects).length });\n    }\n}\n\n// Example of how it might be instantiated and used (e.g., in a thunk or middleware)\n//\n// import { store } from '../store'; // Or get dispatch/getState from thunkAPI\n//\n// const effectsEngine = new ConditionalEffectsEngine(store.dispatch, store.getState);\n// effectsEngine.evaluateAndApplyEffects(); "],"names":["logger","Logger","getInstance","mapStylePropertyToVisualEffectKey","styleProperty","toLowerCase","directMatch","sampleVisualEffect","isVisible","Object","keys","includes","ConditionalEffectsEngine","constructor","dispatch","getState","this","log","evaluateAndApplyEffects","state","conditions","selectProcessedConditionsFromLogic","allParametersByPartId","parameters","parameterValues","allPartsById","parts","partsById","level","processedConditionsCount","length","parameterValuesKeys","setVisualEffectsBatch","newEffects","processedCond","conditionResult","rule","originalRule","valueToEvaluateAgainst","targetPartPks","targetPartIds","map","id","parseInt","filter","isNaN","Array","isArray","sourceDescription","parameter","sourceType","undefined","partId","parameterName","queryResult","inventreeApi","endpoints","getPartParameters","select","selectGetPartParametersQuery","status","data","targetParameter","find","p","_a","template_detail","name","warn","queryStatus","attributeName","partData","entityId","selectGenericHaEntityActualState","haAttributeName","selectGenericHaEntityAttribute","operator","value","normalizedOperator","String","trim","numParamValGt","parseFloat","numValToCompareGt","numParamValLt","numValToCompareLt","conditionId","valueEvaluated","effects","effectDef","effectToApply","currentTargetPartPks","split","pk","type","styleValue","visualEffectKey","opacityVal","pks","effect","assign","originalRuleParameter","evaluatedValue","comparedTo","newEffectsCount"],"mappings":"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"}