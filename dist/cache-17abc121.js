import{L as e,_ as t}from"./editor-5ac0c775.js";import{forwardHaptic as r}from"custom-card-helpers";import"lit";import"lit/decorators.js";const a=e.getInstance();function n(e,t,r={}){try{r.source,a.log("MetricsTracker",`${e}/${t} [${r.source||"unknown"}]`,Object.assign({category:"metrics",subsystem:"tracking"},r))}catch(e){a.error("MetricsTracker",`Error tracking metrics: ${e}`,{category:"metrics",subsystem:"error"})}}function o(e){return`Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}var i=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")(),s=()=>Math.random().toString(36).substring(7).split("").join("."),c={INIT:`@@redux/INIT${s()}`,REPLACE:`@@redux/REPLACE${s()}`,PROBE_UNKNOWN_ACTION:()=>`@@redux/PROBE_UNKNOWN_ACTION${s()}`};function l(e){if("object"!=typeof e||null===e)return!1;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t||null===Object.getPrototypeOf(e)}function d(e,t,r){if("function"!=typeof e)throw new Error(o(2));if("function"==typeof t&&"function"==typeof r||"function"==typeof r&&"function"==typeof arguments[3])throw new Error(o(0));if("function"==typeof t&&void 0===r&&(r=t,t=void 0),void 0!==r){if("function"!=typeof r)throw new Error(o(1));return r(d)(e,t)}let a=e,n=t,s=new Map,u=s,p=0,f=!1;function g(){u===s&&(u=new Map,s.forEach(((e,t)=>{u.set(t,e)})))}function m(){if(f)throw new Error(o(3));return n}function h(e){if("function"!=typeof e)throw new Error(o(4));if(f)throw new Error(o(5));let t=!0;g();const r=p++;return u.set(r,e),function(){if(t){if(f)throw new Error(o(6));t=!1,g(),u.delete(r),s=null}}}function y(e){if(!l(e))throw new Error(o(7));if(void 0===e.type)throw new Error(o(8));if("string"!=typeof e.type)throw new Error(o(17));if(f)throw new Error(o(9));try{f=!0,n=a(n,e)}finally{f=!1}return(s=u).forEach((e=>{e()})),e}y({type:c.INIT});return{dispatch:y,subscribe:h,getState:m,replaceReducer:function(e){if("function"!=typeof e)throw new Error(o(10));a=e,y({type:c.REPLACE})},[i]:function(){const e=h;return{subscribe(t){if("object"!=typeof t||null===t)throw new Error(o(11));function r(){const e=t;e.next&&e.next(m())}r();return{unsubscribe:e(r)}},[i](){return this}}}}}function u(e){const t=Object.keys(e),r={};for(let a=0;a<t.length;a++){const n=t[a];"function"==typeof e[n]&&(r[n]=e[n])}const a=Object.keys(r);let n;try{!function(e){Object.keys(e).forEach((t=>{const r=e[t];if(void 0===r(void 0,{type:c.INIT}))throw new Error(o(12));if(void 0===r(void 0,{type:c.PROBE_UNKNOWN_ACTION()}))throw new Error(o(13))}))}(r)}catch(e){n=e}return function(e={},t){if(n)throw n;let i=!1;const s={};for(let n=0;n<a.length;n++){const c=a[n],l=r[c],d=e[c],u=l(d,t);if(void 0===u)throw t&&t.type,new Error(o(14));s[c]=u,i=i||u!==d}return i=i||a.length!==Object.keys(e).length,i?s:e}}function p(...e){return 0===e.length?e=>e:1===e.length?e[0]:e.reduce(((e,t)=>(...r)=>e(t(...r))))}var f=Symbol.for("immer-nothing"),g=Symbol.for("immer-draftable"),m=Symbol.for("immer-state");function h(e,...t){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var y=Object.getPrototypeOf;function v(e){return!!e&&!!e[m]}function S(e){return!!e&&(w(e)||Array.isArray(e)||!!e[g]||!!e.constructor?.[g]||C(e)||_(e))}var b=Object.prototype.constructor.toString();function w(e){if(!e||"object"!=typeof e)return!1;const t=y(e);if(null===t)return!0;const r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===b}function k(e,t){0===P(e)?Reflect.ownKeys(e).forEach((r=>{t(r,e[r],e)})):e.forEach(((r,a)=>t(a,r,e)))}function P(e){const t=e[m];return t?t.type_:Array.isArray(e)?1:C(e)?2:_(e)?3:0}function I(e,t){return 2===P(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function $(e,t,r){const a=P(e);2===a?e.set(t,r):3===a?e.add(r):e[t]=r}function C(e){return e instanceof Map}function _(e){return e instanceof Set}function E(e){return e.copy_||e.base_}function A(e,t){if(C(e))return new Map(e);if(_(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const r=w(e);if(!0===t||"class_only"===t&&!r){const t=Object.getOwnPropertyDescriptors(e);delete t[m];let r=Reflect.ownKeys(t);for(let a=0;a<r.length;a++){const n=r[a],o=t[n];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[n]={configurable:!0,writable:!0,enumerable:o.enumerable,value:e[n]})}return Object.create(y(e),t)}{const t=y(e);if(null!==t&&r)return{...e};const a=Object.create(t);return Object.assign(a,e)}}function T(e,t=!1){return D(e)||v(e)||!S(e)||(P(e)>1&&(e.set=e.add=e.clear=e.delete=j),Object.freeze(e),t&&Object.entries(e).forEach((([e,t])=>T(t,!0)))),e}function j(){h(2)}function D(e){return Object.isFrozen(e)}var R,O={};function F(e){const t=O[e];return t||h(0),t}function M(){return R}function N(e,t){t&&(F("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function x(e){V(e),e.drafts_.forEach(W),e.drafts_=null}function V(e){e===R&&(R=e.parent_)}function L(e){return R={drafts_:[],parent_:R,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function W(e){const t=e[m];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function B(e,t){t.unfinalizedDrafts_=t.drafts_.length;const r=t.drafts_[0];return void 0!==e&&e!==r?(r[m].modified_&&(x(t),h(4)),S(e)&&(e=q(t,e),t.parent_||U(t,e)),t.patches_&&F("Patches").generateReplacementPatches_(r[m].base_,e,t.patches_,t.inversePatches_)):e=q(t,r,[]),x(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==f?e:void 0}function q(e,t,r){if(D(t))return t;const a=t[m];if(!a)return k(t,((n,o)=>z(e,a,t,n,o,r))),t;if(a.scope_!==e)return t;if(!a.modified_)return U(e,a.base_,!0),a.base_;if(!a.finalized_){a.finalized_=!0,a.scope_.unfinalizedDrafts_--;const t=a.copy_;let n=t,o=!1;3===a.type_&&(n=new Set(t),t.clear(),o=!0),k(n,((n,i)=>z(e,a,t,n,i,r,o))),U(e,t,!1),r&&e.patches_&&F("Patches").generatePatches_(a,r,e.patches_,e.inversePatches_)}return a.copy_}function z(e,t,r,a,n,o,i){if(v(n)){const i=q(e,n,o&&t&&3!==t.type_&&!I(t.assigned_,a)?o.concat(a):void 0);if($(r,a,i),!v(i))return;e.canAutoFreeze_=!1}else i&&r.add(n);if(S(n)&&!D(n)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;q(e,n),t&&t.scope_.parent_||"symbol"==typeof a||!Object.prototype.propertyIsEnumerable.call(r,a)||U(e,n)}}function U(e,t,r=!1){!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&T(t,r)}var K={get(e,t){if(t===m)return e;const r=E(e);if(!I(r,t))return function(e,t,r){const a=Y(t,r);return a?"value"in a?a.value:a.get?.call(e.draft_):void 0}(e,r,t);const a=r[t];return e.finalized_||!S(a)?a:a===J(e.base_,t)?(X(e),e.copy_[t]=Q(a,e)):a},has:(e,t)=>t in E(e),ownKeys:e=>Reflect.ownKeys(E(e)),set(e,t,r){const a=Y(E(e),t);if(a?.set)return a.set.call(e.draft_,r),!0;if(!e.modified_){const a=J(E(e),t),i=a?.[m];if(i&&i.base_===r)return e.copy_[t]=r,e.assigned_[t]=!1,!0;if(((n=r)===(o=a)?0!==n||1/n==1/o:n!=n&&o!=o)&&(void 0!==r||I(e.base_,t)))return!0;X(e),H(e)}var n,o;return e.copy_[t]===r&&(void 0!==r||t in e.copy_)||Number.isNaN(r)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=r,e.assigned_[t]=!0),!0},deleteProperty:(e,t)=>(void 0!==J(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,X(e),H(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0),getOwnPropertyDescriptor(e,t){const r=E(e),a=Reflect.getOwnPropertyDescriptor(r,t);return a?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:a.enumerable,value:r[t]}:a},defineProperty(){h(11)},getPrototypeOf:e=>y(e.base_),setPrototypeOf(){h(12)}},G={};function J(e,t){const r=e[m];return(r?E(r):e)[t]}function Y(e,t){if(!(t in e))return;let r=y(e);for(;r;){const e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=y(r)}}function H(e){e.modified_||(e.modified_=!0,e.parent_&&H(e.parent_))}function X(e){e.copy_||(e.copy_=A(e.base_,e.scope_.immer_.useStrictShallowCopy_))}k(K,((e,t)=>{G[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),G.deleteProperty=function(e,t){return G.set.call(this,e,t,void 0)},G.set=function(e,t,r){return K.set.call(this,e[0],t,r,e[0])};function Q(e,t){const r=C(e)?F("MapSet").proxyMap_(e,t):_(e)?F("MapSet").proxySet_(e,t):function(e,t){const r=Array.isArray(e),a={type_:r?1:0,scope_:t?t.scope_:M(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let n=a,o=K;r&&(n=[a],o=G);const{revoke:i,proxy:s}=Proxy.revocable(n,o);return a.draft_=s,a.revoke_=i,s}(e,t);return(t?t.scope_:M()).drafts_.push(r),r}function Z(e){if(!S(e)||D(e))return e;const t=e[m];let r;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,r=A(e,t.scope_.immer_.useStrictShallowCopy_)}else r=A(e,!0);return k(r,((e,t)=>{$(r,e,Z(t))})),t&&(t.finalized_=!1),r}var ee=new class{constructor(e){this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(e,t,r)=>{if("function"==typeof e&&"function"!=typeof t){const r=t;t=e;const a=this;return function(e=r,...n){return a.produce(e,(e=>t.call(this,e,...n)))}}let a;if("function"!=typeof t&&h(6),void 0!==r&&"function"!=typeof r&&h(7),S(e)){const n=L(this),o=Q(e,void 0);let i=!0;try{a=t(o),i=!1}finally{i?x(n):V(n)}return N(n,r),B(a,n)}if(!e||"object"!=typeof e){if(a=t(e),void 0===a&&(a=e),a===f&&(a=void 0),this.autoFreeze_&&T(a,!0),r){const t=[],n=[];F("Patches").generateReplacementPatches_(e,a,t,n),r(t,n)}return a}h(1)},this.produceWithPatches=(e,t)=>{if("function"==typeof e)return(t,...r)=>this.produceWithPatches(t,(t=>e(t,...r)));let r,a;return[this.produce(e,t,((e,t)=>{r=e,a=t})),r,a]},"boolean"==typeof e?.autoFreeze&&this.setAutoFreeze(e.autoFreeze),"boolean"==typeof e?.useStrictShallowCopy&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){S(e)||h(8),v(e)&&(e=function(e){v(e)||h(10);return Z(e)}(e));const t=L(this),r=Q(e,void 0);return r[m].isManual_=!0,V(t),r}finishDraft(e,t){const r=e&&e[m];r&&r.isManual_||h(9);const{scope_:a}=r;return N(a,t),B(void 0,a)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let r;for(r=t.length-1;r>=0;r--){const a=t[r];if(0===a.path.length&&"replace"===a.op){e=a.value;break}}r>-1&&(t=t.slice(r+1));const a=F("Patches").applyPatches_;return v(e)?a(e,t):this.produce(e,(e=>a(e,t)))}},te=ee.produce;ee.produceWithPatches.bind(ee),ee.setAutoFreeze.bind(ee),ee.setUseStrictShallowCopy.bind(ee),ee.applyPatches.bind(ee),ee.createDraft.bind(ee),ee.finishDraft.bind(ee);var re=e=>Array.isArray(e)?e:[e];function ae(e){const t=Array.isArray(e[0])?e[0]:e;return function(e,t="expected all items to be functions, instead received the following types: "){if(!e.every((e=>"function"==typeof e))){const r=e.map((e=>"function"==typeof e?`function ${e.name||"unnamed"}()`:typeof e)).join(", ");throw new TypeError(`${t}[${r}]`)}}(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}var ne="undefined"!=typeof WeakRef?WeakRef:class{constructor(e){this.value=e}deref(){return this.value}};function oe(e,t={}){let r={s:0,v:void 0,o:null,p:null};const{resultEqualityCheck:a}=t;let n,o=0;function i(){let t=r;const{length:i}=arguments;for(let e=0,r=i;e<r;e++){const r=arguments[e];if("function"==typeof r||"object"==typeof r&&null!==r){let e=t.o;null===e&&(t.o=e=new WeakMap);const a=e.get(r);void 0===a?(t={s:0,v:void 0,o:null,p:null},e.set(r,t)):t=a}else{let e=t.p;null===e&&(t.p=e=new Map);const a=e.get(r);void 0===a?(t={s:0,v:void 0,o:null,p:null},e.set(r,t)):t=a}}const s=t;let c;if(1===t.s)c=t.v;else if(c=e.apply(null,arguments),o++,a){const e=n?.deref?.()??n;null!=e&&a(e,c)&&(c=e,0!==o&&o--);n="object"==typeof c&&null!==c||"function"==typeof c?new ne(c):c}return s.s=1,s.v=c,c}return i.clearCache=()=>{r={s:0,v:void 0,o:null,p:null},i.resetResultsCount()},i.resultsCount=()=>o,i.resetResultsCount=()=>{o=0},i}function ie(e,...t){const r="function"==typeof e?{memoize:e,memoizeOptions:t}:e,a=(...e)=>{let t,a=0,n=0,o={},i=e.pop();"object"==typeof i&&(o=i,i=e.pop()),function(e,t="expected a function, instead received "+typeof e){if("function"!=typeof e)throw new TypeError(t)}(i,`createSelector expects an output function after the inputs, but received: [${typeof i}]`);const s={...r,...o},{memoize:c,memoizeOptions:l=[],argsMemoize:d=oe,argsMemoizeOptions:u=[],devModeChecks:p={}}=s,f=re(l),g=re(u),m=ae(e),h=c((function(){return a++,i.apply(null,arguments)}),...f),y=d((function(){n++;const e=function(e,t){const r=[],{length:a}=e;for(let n=0;n<a;n++)r.push(e[n].apply(null,t));return r}(m,arguments);return t=h.apply(null,e),t}),...g);return Object.assign(y,{resultFunc:i,memoizedResultFunc:h,dependencies:m,dependencyRecomputations:()=>n,resetDependencyRecomputations:()=>{n=0},lastResult:()=>t,recomputations:()=>a,resetRecomputations:()=>{a=0},memoize:c,argsMemoize:d})};return Object.assign(a,{withTypes:()=>a}),a}var se=ie(oe),ce=Object.assign(((e,t=se)=>{!function(e,t="expected an object, instead received "+typeof e){if("object"!=typeof e)throw new TypeError(t)}(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a "+typeof e);const r=Object.keys(e);return t(r.map((t=>e[t])),((...e)=>e.reduce(((e,t,a)=>(e[r[a]]=t,e)),{})))}),{withTypes:()=>ce});function le(e){return({dispatch:t,getState:r})=>a=>n=>"function"==typeof n?n(t,r,e):a(n)}var de=le(),ue=le,pe="undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"==typeof arguments[0]?p:p.apply(null,arguments)};function fe(e,t){function r(...r){if(t){let a=t(...r);if(!a)throw new Error(Oe(0));return{type:e,payload:a.payload,..."meta"in a&&{meta:a.meta},..."error"in a&&{error:a.error}}}return{type:e,payload:r[0]}}return r.toString=()=>`${e}`,r.type=e,r.match=t=>function(e){return l(e)&&"type"in e&&"string"==typeof e.type}(t)&&t.type===e,r}var ge=class e extends Array{constructor(...t){super(...t),Object.setPrototypeOf(this,e.prototype)}static get[Symbol.species](){return e}concat(...e){return super.concat.apply(this,e)}prepend(...t){return 1===t.length&&Array.isArray(t[0])?new e(...t[0].concat(this)):new e(...t.concat(this))}};function me(e){return S(e)?te(e,(()=>{})):e}function he(e,t,r){return e.has(t)?e.get(t):e.set(t,r(t)).get(t)}var ye=e=>t=>{setTimeout(t,e)},ve=e=>function(t){const{autoBatch:r=!0}=t??{};let a=new ge(e);return r&&a.push(((e={type:"raf"})=>t=>(...r)=>{const a=t(...r);let n=!0,o=!1,i=!1;const s=new Set,c="tick"===e.type?queueMicrotask:"raf"===e.type?"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:ye(10):"callback"===e.type?e.queueNotification:ye(e.timeout),l=()=>{i=!1,o&&(o=!1,s.forEach((e=>e())))};return Object.assign({},a,{subscribe(e){const t=a.subscribe((()=>n&&e()));return s.add(e),()=>{t(),s.delete(e)}},dispatch(e){try{return n=!e?.meta?.RTK_autoBatch,o=!n,o&&(i||(i=!0,c(l))),a.dispatch(e)}finally{n=!0}}})})("object"==typeof r?r:void 0)),a};function Se(e){const t={},r=[];let a;const n={addCase(e,r){const a="string"==typeof e?e:e.type;if(!a)throw new Error(Oe(28));if(a in t)throw new Error(Oe(29));return t[a]=r,n},addMatcher:(e,t)=>(r.push({matcher:e,reducer:t}),n),addDefaultCase:e=>(a=e,n)};return e(n),[t,r,a]}function be(...e){return t=>e.some((e=>((e,t)=>{return(r=e)&&"function"==typeof r.match?e.match(t):e(t);var r})(e,t)))}var we=["name","message","stack","code"],ke=class{constructor(e,t){this.payload=e,this.meta=t}_type},Pe=class{constructor(e,t){this.payload=e,this.meta=t}_type},Ie=e=>{if("object"==typeof e&&null!==e){const t={};for(const r of we)"string"==typeof e[r]&&(t[r]=e[r]);return t}return{message:String(e)}},$e="External signal was aborted",Ce=(()=>{function e(e,t,r){const a=fe(e+"/fulfilled",((e,t,r,a)=>({payload:e,meta:{...a||{},arg:r,requestId:t,requestStatus:"fulfilled"}}))),n=fe(e+"/pending",((e,t,r)=>({payload:void 0,meta:{...r||{},arg:t,requestId:e,requestStatus:"pending"}}))),o=fe(e+"/rejected",((e,t,a,n,o)=>({payload:n,error:(r&&r.serializeError||Ie)(e||"Rejected"),meta:{...o||{},arg:a,requestId:t,rejectedWithValue:!!n,requestStatus:"rejected",aborted:"AbortError"===e?.name,condition:"ConditionError"===e?.name}})));return Object.assign((function(e,{signal:i}={}){return(s,c,l)=>{const d=r?.idGenerator?r.idGenerator(e):((e=21)=>{let t="",r=e;for(;r--;)t+="ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64*Math.random()|0];return t})(),u=new AbortController;let p,f;function g(e){f=e,u.abort()}i&&(i.aborted?g($e):i.addEventListener("abort",(()=>g($e)),{once:!0}));const m=async function(){let i;try{let o=r?.condition?.(e,{getState:c,extra:l});if(null!==(m=o)&&"object"==typeof m&&"function"==typeof m.then&&(o=await o),!1===o||u.signal.aborted)throw{name:"ConditionError",message:"Aborted due to condition callback returning false."};const h=new Promise(((e,t)=>{p=()=>{t({name:"AbortError",message:f||"Aborted"})},u.signal.addEventListener("abort",p)}));s(n(d,e,r?.getPendingMeta?.({requestId:d,arg:e},{getState:c,extra:l}))),i=await Promise.race([h,Promise.resolve(t(e,{dispatch:s,getState:c,extra:l,requestId:d,signal:u.signal,abort:g,rejectWithValue:(e,t)=>new ke(e,t),fulfillWithValue:(e,t)=>new Pe(e,t)})).then((t=>{if(t instanceof ke)throw t;return t instanceof Pe?a(t.payload,d,e,t.meta):a(t,d,e)}))])}catch(t){i=t instanceof ke?o(null,d,e,t.payload,t.meta):o(t,d,e)}finally{p&&u.signal.removeEventListener("abort",p)}var m;return r&&!r.dispatchConditionRejection&&o.match(i)&&i.meta.condition||s(i),i}();return Object.assign(m,{abort:g,requestId:d,arg:e,unwrap:()=>m.then(_e)})}}),{pending:n,rejected:o,fulfilled:a,settled:be(o,a),typePrefix:e})}return e.withTypes=()=>e,e})();function _e(e){if(e.meta&&e.meta.rejectedWithValue)throw e.payload;if(e.error)throw e.error;return e.payload}var Ee=Symbol.for("rtk-slice-createasyncthunk");function Ae(e,t){return`${e}/${t}`}function Te({creators:e}={}){const t=e?.asyncThunk?.[Ee];return function(e){const{name:r,reducerPath:a=r}=e;if(!r)throw new Error(Oe(11));const n=("function"==typeof e.reducers?e.reducers(function(){function e(e,t){return{_reducerDefinitionType:"asyncThunk",payloadCreator:e,...t}}return e.withTypes=()=>e,{reducer:e=>Object.assign({[e.name]:(...t)=>e(...t)}[e.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(e,t)=>({_reducerDefinitionType:"reducerWithPrepare",prepare:e,reducer:t}),asyncThunk:e}}()):e.reducers)||{},o=Object.keys(n),i={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},s={addCase(e,t){const r="string"==typeof e?e:e.type;if(!r)throw new Error(Oe(12));if(r in i.sliceCaseReducersByType)throw new Error(Oe(13));return i.sliceCaseReducersByType[r]=t,s},addMatcher:(e,t)=>(i.sliceMatchers.push({matcher:e,reducer:t}),s),exposeAction:(e,t)=>(i.actionCreators[e]=t,s),exposeCaseReducer:(e,t)=>(i.sliceCaseReducersByName[e]=t,s)};function c(){const[t={},r=[],a]="function"==typeof e.extraReducers?Se(e.extraReducers):[e.extraReducers],n={...t,...i.sliceCaseReducersByType};return function(e,t){let r,[a,n,o]=Se(t);if("function"==typeof e)r=()=>me(e());else{const t=me(e);r=()=>t}function i(e=r(),t){let i=[a[t.type],...n.filter((({matcher:e})=>e(t))).map((({reducer:e})=>e))];return 0===i.filter((e=>!!e)).length&&(i=[o]),i.reduce(((e,r)=>{if(r){if(v(e)){const a=r(e,t);return void 0===a?e:a}if(S(e))return te(e,(e=>r(e,t)));{const a=r(e,t);if(void 0===a){if(null===e)return e;throw Error("A case reducer on a non-draftable value must not return undefined")}return a}}return e}),e)}return i.getInitialState=r,i}(e.initialState,(e=>{for(let t in n)e.addCase(t,n[t]);for(let t of i.sliceMatchers)e.addMatcher(t.matcher,t.reducer);for(let t of r)e.addMatcher(t.matcher,t.reducer);a&&e.addDefaultCase(a)}))}o.forEach((a=>{const o=n[a],i={reducerName:a,type:Ae(r,a),createNotation:"function"==typeof e.reducers};!function(e){return"asyncThunk"===e._reducerDefinitionType}(o)?function({type:e,reducerName:t,createNotation:r},a,n){let o,i;if("reducer"in a){if(r&&!function(e){return"reducerWithPrepare"===e._reducerDefinitionType}(a))throw new Error(Oe(17));o=a.reducer,i=a.prepare}else o=a;n.addCase(e,o).exposeCaseReducer(t,o).exposeAction(t,i?fe(e,i):fe(e))}(i,o,s):function({type:e,reducerName:t},r,a,n){if(!n)throw new Error(Oe(18));const{payloadCreator:o,fulfilled:i,pending:s,rejected:c,settled:l,options:d}=r,u=n(e,o,d);a.exposeAction(t,u),i&&a.addCase(u.fulfilled,i);s&&a.addCase(u.pending,s);c&&a.addCase(u.rejected,c);l&&a.addMatcher(u.settled,l);a.exposeCaseReducer(t,{fulfilled:i||Re,pending:s||Re,rejected:c||Re,settled:l||Re})}(i,o,s,t)}));const l=e=>e,d=new Map,u=new WeakMap;let p;function f(e,t){return p||(p=c()),p(e,t)}function g(){return p||(p=c()),p.getInitialState()}function m(t,r=!1){function a(e){let n=e[t];return void 0===n&&r&&(n=he(u,a,g)),n}function n(t=l){const a=he(d,r,(()=>new WeakMap));return he(a,t,(()=>{const a={};for(const[n,o]of Object.entries(e.selectors??{}))a[n]=je(o,t,(()=>he(u,t,g)),r);return a}))}return{reducerPath:t,getSelectors:n,get selectors(){return n(a)},selectSlice:a}}const h={name:r,reducer:f,actions:i.actionCreators,caseReducers:i.sliceCaseReducersByName,getInitialState:g,...m(a),injectInto(e,{reducerPath:t,...r}={}){const n=t??a;return e.inject({reducerPath:n,reducer:f},r),{...h,...m(n,!0)}}};return h}}function je(e,t,r,a){function n(n,...o){let i=t(n);return void 0===i&&a&&(i=r()),e(i,...o)}return n.unwrapped=e,n}var De=Te();function Re(){}function Oe(e){return`Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}class Fe{constructor(e){this.hass=e,console.debug("🌈 WLED Service: Initialized")}async toggleLED(e){try{if(!e)throw r("failure"),new Error("No entity_id provided");const t=this.hass.states[e];if(!t)throw r("failure"),new Error(`Entity ${e} not found`);await this.hass.callService("light","on"===t.state?"turn_off":"turn_on",{entity_id:e}),r("success")}catch(e){throw r("failure"),console.error("Failed to toggle LED:",e),e}}async locatePart(e,t){var a,n,o;try{if(console.debug("🌈 WLED: Starting locate part process",{part:e,config:t}),!t.entity_id)throw r("failure"),new Error("No entity_id configured for WLED");const i=null===(n=null===(a=e.parameters)||void 0===a?void 0:a.find((e=>{var r;return(null===(r=e.template_detail)||void 0===r?void 0:r.name)===t.parameter_name})))||void 0===n?void 0:n.data;if(!i)throw new Error(`No ${t.parameter_name} parameter found for part`);const s=parseInt(i);console.debug("🌈 WLED: Using LED position:",s);const c=this.hass.states[t.entity_id];if(!c)throw new Error(`Entity ${t.entity_id} not found`);const l=(null===(o=t.ip_address)||void 0===o?void 0:o.replace("http://",""))||"192.168.0.61";console.debug("🌈 WLED IP:",l);const d="on"===c.state;await this.hass.callService("rest_command","wled_segment",{url:`http://${l}/json/state`,payload:JSON.stringify(d?{on:!1}:{on:!0,bri:t.intensity||128,seg:[{id:0,start:s-1,stop:s,col:[[255,0,0],[0,0,0],[0,0,0]],fx:0}]})}),r("success")}catch(e){throw r("failure"),console.error("Failed to locate part with WLED:",e),e}}}const Me=e.getInstance();const Ne=new class{constructor(){this.lastApiCallTimestamp=0,this.lastApiFailureTimestamp=0,Me.log("InventreeApiService","Initialized.")}async request(e,t={}){const r=Pr.getState().api,a=r.url,n=r.apiKey,o=r.throttleDelayMs,i=r.failedRequestRetryDelayMs;if(!a||!n){const e="API base URL or API key is not configured in Redux store (apiSlice).";throw Me.error("InventreeApiService",e),this.lastApiFailureTimestamp=Date.now(),new Error(e)}const s=`${a.endsWith("/")?a.slice(0,-1):a}/${e.startsWith("/")?e.substring(1):e}`,c=new Headers(Object.assign({Authorization:`Token ${n}`,"Content-Type":"application/json"},t.headers||{}));if(Me.log("InventreeApiService",`Requesting URL: ${s}`,{method:t.method||"GET",level:"debug"}),this.lastApiFailureTimestamp>0){const e=Date.now()-this.lastApiFailureTimestamp;if(e<i){const t=i-e;Me.warn("InventreeApiService",`Recent API Failure: Delaying next request by ${t}ms. Cooldown until ${new Date(Date.now()+t).toISOString()}`),await new Promise((e=>setTimeout(e,t)))}}if(o>0){const e=Date.now()-this.lastApiCallTimestamp;if(e<o){const t=o-e;Me.log("InventreeApiService",`General Throttling: Delaying by ${t}ms.`,{level:"debug"}),await new Promise((e=>setTimeout(e,t)))}}this.lastApiCallTimestamp=Date.now();try{const e=await fetch(s,Object.assign(Object.assign({},t),{headers:c}));if(!e.ok){let t;try{t=await e.json()}catch(r){t=await e.text()}const r=`API request failed: ${e.status} ${e.statusText}`;throw Me.error("InventreeApiService",r,{url:s,status:e.status,errorData:t}),this.lastApiFailureTimestamp=Date.now(),new Error(r)}if(204===e.status)return this.lastApiFailureTimestamp=0,null;const r=await e.json();return this.lastApiFailureTimestamp=0,r}catch(e){throw Me.error("InventreeApiService",`Catch-all for ${s}. Setting failure timestamp. Error:`,e),this.lastApiFailureTimestamp=Date.now(),e}}async getPart(e){Me.log("InventreeApiService",`Fetching part ${e}...`);try{return await this.request(`part/${e}/`)}catch(t){return Me.error("InventreeApiService",`Failed to get part ${e}:`,t),null}}async getParts(e={}){Me.log("InventreeApiService","Fetching parts with params:",e);try{const t=new URLSearchParams(e).toString();return await this.request(`part/?${t}`)}catch(t){return Me.error("InventreeApiService","Failed to get parts:",{params:e,error:t}),[]}}async adjustStock(e,t,r,a){var n;Me.log("InventreeApiService",`Adjusting stock for part ${e} by ${t}. Location: ${r}, Notes: "${a}"`);try{if(0===t)Me.log("InventreeApiService",`Relative amount is 0 for part ${e}, no stock change needed. Fetching current stock.`);else if(t>0){const n=await this.addStockItem(e,t,r,a);if(!n)throw new Error("Failed to add stock item during positive adjustment.");Me.log("InventreeApiService",`Added stock item PK: ${n.pk} for part ${e}.`)}else{const o=Math.abs(t);Me.log("InventreeApiService",`Attempting to remove ${o} for part ${e}.`);await this.consolidateStockForPart(e,r,a||"Consolidating before stock removal");const i=await this.getStockItemsForPart(e,r),s=null!==(n=null==i?void 0:i.reduce(((e,t)=>e+parseFloat(t.quantity||"0")),0))&&void 0!==n?n:0;if(!i||0===i.length||s<o)Me.warn("InventreeApiService",`Cannot remove ${o} for part ${e}: Insufficient stock (${s}) available after consolidation attempt.`);else{const t=i[0];if(!t)throw Me.error("InventreeApiService",`Logic error: Stock exists (${s}) but no stock item found after consolidation for part ${e}.`),new Error("Stock item not found after consolidation despite available quantity.");Me.log("InventreeApiService",`Removing ${o} from stock item PK ${t.pk} for part ${e}.`);await this.removeStockItems([{pk:t.pk,quantity:o}],a||"Stock removal")||Me.error("InventreeApiService",`Stock removal API call failed for part ${e}, item ${t.pk}.`)}}Me.log("InventreeApiService",`Fetching final part details for ${e} after stock adjustment.`);const o=await this.getPart(e);return o?(Me.log("InventreeApiService",`Stock adjustment process complete for part ${e}. Final stock: ${o.in_stock}.`),{pk:e,newTotalStock:o.in_stock}):(Me.error("InventreeApiService",`Failed to fetch updated part details for part ${e} after stock adjustment.`),null)}catch(t){Me.error("InventreeApiService",`Failed to adjust stock for part ${e}:`,t);try{const t=await this.getPart(e);if(t)return Me.warn("InventreeApiService",`Returning last known stock (${t.in_stock}) for part ${e} after adjustment error.`),{pk:e,newTotalStock:t.in_stock}}catch(t){Me.error("InventreeApiService",`Failed to fetch final part details for ${e} even after catching primary error:`,t)}return null}}async getPartParameters(e){Me.log("InventreeApiService",`Fetching parameters for part ${e}...`);try{return await this.request(`part/parameter/?part=${e}`)}catch(t){return Me.error("InventreeApiService",`Failed to get parameters for part ${e}:`,t),null}}async updatePartParameter(e,t){Me.log("InventreeApiService",`Updating parameter ${e} to value: "${t}"...`);try{return await this.request(`part/parameter/${e}/`,{method:"PATCH",body:JSON.stringify({data:t})})}catch(t){return Me.error("InventreeApiService",`Failed to update parameter ${e}:`,t),null}}async getStockItemsForPart(e,t){Me.log("InventreeApiService",`Fetching stock items for part ${e}${t?` at location ${t}`:""}...`);try{const r=new URLSearchParams({part:String(e)});return void 0!==t&&r.set("location",String(t)),await this.request(`stock/?${r.toString()}`)}catch(t){return Me.error("InventreeApiService",`Failed to get stock items for part ${e}:`,t),null}}async addStockItem(e,t,r,a){Me.log("InventreeApiService",`Adding stock for part ${e}: quantity ${t}, location ${r}, notes: "${a}"`);try{const n={part:e,quantity:String(t),status:10};return void 0!==r&&(n.location=r),a&&(n.notes=a),await this.request("stock/",{method:"POST",body:JSON.stringify(n)})}catch(t){return Me.error("InventreeApiService",`Failed to add stock for part ${e}:`,t),null}}async removeStockItems(e,t){if(Me.log("InventreeApiService",`Removing stock for items: ${e.map((e=>`PK: ${e.pk}, Qty: ${e.quantity}`)).join("; ")}. Notes: "${t}"`),0===e.length)return Me.warn("InventreeApiService","removeStockItems called with empty stockItems array."),{success:!0,message:"No items to remove."};try{const r={items:e.map((e=>({pk:e.pk,quantity:String(e.quantity)})))};return t&&(r.notes=t),await this.request("stock/remove/",{method:"POST",body:JSON.stringify(r)})}catch(t){return Me.error("InventreeApiService","Failed to remove stock items:",{stockItems:e,error:t}),null}}async deleteStockItem(e){Me.log("InventreeApiService",`Deleting stock item PK ${e}...`);try{return void await this.request(`stock/${e}/`,{method:"DELETE"})}catch(t){return Me.error("InventreeApiService",`Failed to delete stock item ${e}:`,t),null}}async consolidateStockForPart(e,t,r){var a;Me.log("InventreeApiService",`Consolidating stock for part ${e}${void 0!==t?` to location ${t}`:""}...`);try{const n=await this.getStockItemsForPart(e);if(!n)return Me.error("InventreeApiService",`Failed to fetch existing stock items for part ${e} during consolidation.`),null;if(0===n.length)return Me.log("InventreeApiService",`No stock items found for part ${e} to consolidate.`),null;let o=0;n.forEach((e=>{const t=parseFloat(e.quantity);isNaN(t)?Me.warn("InventreeApiService",`Invalid quantity found for stock item ${e.pk}: ${e.quantity}. Skipping in total calculation.`):o+=t}));const i=r||`Consolidated from ${n.length} item(s).`,s=n.map((e=>e.pk));let c=t;void 0===c&&(c=null===(a=n[0])||void 0===a?void 0:a.location);const l=null===c?void 0:c;if(void 0===l&&o>0){const t=n.find((e=>null!==e.location&&void 0!==e.location));if(!t)return Me.error("InventreeApiService",`Cannot determine location for consolidated stock for part ${e}. Provide targetLocationId or ensure at least one existing item has a location.`),null;Me.warn("InventreeApiService",`No targetLocationId provided and first item had no location. Using location ${t.location} from item ${t.pk}.`),c=t.location}let d=null;if(o>0){if(d=await this.addStockItem(e,o,l,i),!d)return Me.error("InventreeApiService",`Failed to create new consolidated stock item for part ${e}. Aborting consolidation.`),null;Me.log("InventreeApiService",`Created new consolidated stock item PK: ${d.pk}`);const t=s.indexOf(d.pk);t>-1&&s.splice(t,1)}else Me.log("InventreeApiService",`Total quantity is 0 for part ${e}. Proceeding to delete old items.`);Me.log("InventreeApiService",`Deleting ${s.length} old stock items for part ${e}: [${s.join(", ")}]`);let u=0;for(const e of s){null===await this.deleteStockItem(e)&&(Me.warn("InventreeApiService",`Failed to delete old stock item ${e} during consolidation.`),u++)}return u>0&&Me.warn("InventreeApiService",`Consolidation completed for part ${e}, but ${u} old stock items failed to delete.`),Me.log("InventreeApiService",`Successfully consolidated stock for part ${e}. Returning ${d?`new item PK ${d.pk}`:"null (zero stock)"}.`),d}catch(t){return Me.error("InventreeApiService",`Failed to consolidate stock for part ${e}:`,t),null}}},xe=e.getInstance(),Ve=Ce("parts/fetchPartDetails",(async(e,{rejectWithValue:t,getState:r})=>{var a;xe.info("partsSlice",`Fetching details for part ${e}...`);try{const{api:n}=r();if(!(null===(a=n.directApiConfig)||void 0===a?void 0:a.url)||!n.directApiConfig.apiKey)return xe.warn("partsSlice","Direct API URL or API Key not configured. Cannot fetch part details."),t("Direct API not configured.");const o=await Ne.getPart(e);return o?(xe.log("partsSlice",`Successfully fetched part details for ${e}`,o),o):(xe.warn("partsSlice",`No data returned for part ${e} from API.`),t(`Part ${e} not found or API error.`))}catch(r){return xe.error("partsSlice",`Error fetching part details for ${e}:`,r),t(r.message||`Failed to fetch part ${e}`)}})),Le=Ce("parts/locatePartById",(async(e,{getState:t,dispatch:r,rejectWithValue:a})=>{var n,o,i;const s=t(),c=s.parts.partsById[e],l=null===(o=null===(n=s.config.resolvedConfig)||void 0===n?void 0:n.services)||void 0===o?void 0:o.wled;if(!c)return xe.warn("partsSlice",`Part with ID ${e} not found for location.`),a(`Part with ID ${e} not found.`);if(!(l&&l.enabled&&l.entity_id&&l.parameter_name))return xe.warn("partsSlice",`WLED service not configured or enabled for part ${e}.`),a("WLED service not configured or enabled.");const d=new Fe(s.hass.hass),u=null===(i=c.parameters)||void 0===i?void 0:i.find((e=>{var t;return(null===(t=e.template_detail)||void 0===t?void 0:t.name)===l.parameter_name}));if(!u||!u.data)return xe.warn("partsSlice",`Location parameter '${l.parameter_name}' not found or empty for part ${e}.`),a(`Location parameter not found for part ${e}.`);try{await d.locatePart(c,l),xe.log("partsSlice",`Successfully triggered WLED location for part ${e} at segment ${u.data}.`),setTimeout((()=>{r(Be.actions.setLocatingPartId(null))}),5e3)}catch(t){return xe.error("partsSlice",`Error locating part ${e} via WLED:`,t),a(t.message||`Failed to locate part ${e}.`)}})),We=Ce("parts/adjustPartStock",(async({partId:e,amount:t,locationId:r,notes:a},{rejectWithValue:n})=>{xe.info("partsSlice",`Adjusting stock for part ${e} by ${t}. Location: ${r}, Notes: "${a}"`);try{const o=await Ne.adjustStock(e,t,r,a);if(!o||"number"!=typeof o.newTotalStock){xe.error("partsSlice",`Stock adjustment for part ${e} failed or did not return expected result format.`,o);return n(`Stock adjustment failed: ${o?"API response missing newTotalStock":"API call failed"}.`)}return xe.log("partsSlice",`Stock for part ${e} adjusted successfully via API. New total stock: ${o.newTotalStock}.`),{partId:o.pk,newTotalStock:o.newTotalStock}}catch(t){return xe.error("partsSlice",`Error calling inventreeApiService.adjustStock for part ${e}:`,t),n(t.message||`Failed to adjust stock for part ${e}.`)}})),Be=De({name:"parts",initialState:{partsById:{},partsByEntity:{},loading:!1,error:null,locatingPartId:null,adjustingStockPartId:null,adjustmentError:null},reducers:{setParts(e,t){const{entityId:r,parts:a}=t.payload,n=[];a.forEach((t=>{e.partsById[t.pk]=Object.assign(Object.assign({},e.partsById[t.pk]),t),n.push(t.pk)})),e.partsByEntity[r]=n,xe.log("partsSlice",`Set ${a.length} parts for entity '${r}'. Part IDs: [${n.join(", ")}]`,{level:"debug"})},updatePart(e,t){const r=t.payload;e.partsById[r.pk]?(e.partsById[r.pk]=Object.assign(Object.assign({},e.partsById[r.pk]),r),xe.log("partsSlice",`Updated part ${r.pk} in partsById.`,{level:"debug"})):(e.partsById[r.pk]=r,xe.log("partsSlice",`Added new part ${r.pk} to partsById.`,{level:"debug"}))},updatePartStock(e,t){const{partId:r,newStock:a}=t.payload,n=e.partsById[r];n?(n.in_stock=a,xe.log("partsSlice",`Updated stock for part ${r} to ${a} in partsById.`,{level:"debug"})):xe.warn("partsSlice",`Attempted to update stock for non-existent partId: ${r}`)},clearParts(e,t){const r=t.payload;xe.log("partsSlice",`Clearing parts mapping for entity '${r}'.`,{level:"debug"}),delete e.partsByEntity[r]},registerEntity(e,t){const r=t.payload;r in e.partsByEntity||(e.partsByEntity[r]=[],xe.log("partsSlice",`Registered entity '${r}' in partsByEntity.`,{level:"debug"}))},partStockUpdateFromWebSocket(e,r){const a=r.payload,{partId:n,quantity:o}=a,i=t(a,["partId","quantity"]),s=e.partsById[n];s?(xe.log("partsSlice",`Processing WebSocket stock update for part ${n}. Current stock: ${s.in_stock}, New quantity from WS: ${o}`),void 0!==o&&(s.in_stock=parseFloat(o)),xe.log("partsSlice",`Part ${n} stock updated to ${s.in_stock} via WebSocket.`,{level:"debug",otherStockData:i})):xe.warn("partsSlice",`Received WebSocket stock update for unknown part ${n}. Triggering fetch.`)},setLocatingPartId(e,t){e.locatingPartId=t.payload}},extraReducers:e=>{e.addCase(Le.pending,((e,t)=>{e.locatingPartId=t.meta.arg})).addCase(Le.rejected,((e,t)=>{e.locatingPartId===t.meta.arg&&(e.locatingPartId=null)})).addCase(Le.fulfilled,((e,t)=>{})).addCase(We.pending,((e,t)=>{var r;const{partId:a,amount:n}=t.meta.arg;e.adjustingStockPartId=a,e.adjustmentError=null;const o=e.partsById[a];if(o){const e=o.in_stock;o.in_stock=(null!==(r=o.in_stock)&&void 0!==r?r:0)+n,xe.log("partsSlice",`Optimistically updated stock for part ${a} from ${e} to ${o.in_stock}`,{level:"debug"})}else xe.warn("partsSlice",`Cannot optimistically update stock for partId ${a}: Part not found.`)})).addCase(We.fulfilled,((e,t)=>{const{partId:r,newTotalStock:a}=t.payload,n=e.partsById[r];n&&(n.in_stock=a),e.adjustingStockPartId===r&&(e.adjustingStockPartId=null),e.adjustmentError=null})).addCase(We.rejected,((e,t)=>{var r;const a=t.meta.arg.partId,n=t.meta.arg;e.adjustmentError=t.payload||t.error.message||"Failed to adjust stock",xe.error("partsSlice",`Stock adjustment failed for part ${a}: ${e.adjustmentError}`);const o=e.partsById[a];o&&"number"==typeof n.amount&&(o.in_stock=(null!==(r=o.in_stock)&&void 0!==r?r:0)-n.amount,xe.warn("partsSlice",`Reverted optimistic stock update for part ${a}. New reverted stock: ${o.in_stock}`)),e.adjustingStockPartId===a&&(e.adjustingStockPartId=null)})).addCase(Ve.pending,((e,t)=>{const r=t.meta.arg;xe.info("partsSlice",`Fetching details for part ${r} (pending)...`),e.loading=!0})).addCase(Ve.fulfilled,((e,t)=>{const r=t.payload;xe.info("partsSlice",`Successfully fetched details for part ${r.pk}. Updating state.`),e.partsById[r.pk]=Object.assign(Object.assign({},e.partsById[r.pk]),r),e.loading=!1})).addCase(Ve.rejected,((e,t)=>{const r=t.meta.arg;xe.error("partsSlice",`Failed to fetch details for part ${r}: ${t.payload||t.error.message}`),e.loading=!1,e.error=t.payload||t.error.message||`Failed to fetch details for part ${r}`}))}}),{setParts:qe,updatePart:ze,updatePartStock:Ue,clearParts:Ke,registerEntity:Ge,partStockUpdateFromWebSocket:Je,setLocatingPartId:Ye}=Be.actions;var He=Be.reducer;const Xe=e=>e.parts.partsByEntity,Qe=e=>e.parts.partsById;se([Qe],(e=>Object.keys(e).map(Number)));const Ze=se([Qe],(e=>Object.values(e)));se([Xe,Qe,(e,t)=>t],((e,t,r)=>{const a=new Set;r.forEach((t=>{const r=e[t];r&&r.forEach((e=>a.add(e)))}));const n=[];return a.forEach((e=>{const r=t[e];r&&n.push(r)})),n})),se([Qe,Xe,(e,t)=>t],((e,t,r)=>{var a;return(null!==(a=t[r])&&void 0!==a?a:[]).map((t=>e[t])).filter((e=>!!e))})),se([e=>e.parts.partsById,(e,t)=>t],((e,t)=>null!=t?e[t]:void 0)),se([Ze],(e=>e)),se([e=>e.parts.partsById,e=>e.parts.partsByEntity,(e,t)=>t],((e,t,r)=>{if(!r)return[];const a=t[r];return a?a.map((t=>e[t])).filter((e=>void 0!==e)):[]})),se([e=>e.parts.partsById,e=>e.parts.partsByEntity,(e,t,r=[])=>({primaryEntityId:t,additionalEntityIds:r})],((e,t,{primaryEntityId:r,additionalEntityIds:a})=>{const n=new Set;if(r){const e=t[r];e&&e.forEach((e=>n.add(e)))}return a.forEach((e=>{const r=t[e];r&&r.forEach((e=>n.add(e)))})),Array.from(n).map((t=>e[t])).filter((e=>void 0!==e))}));const et=e.getInstance(),tt={url:null,apiKey:null,initialized:!1,error:null,throttleDelayMs:200,cacheLifetimeMs:6e4,failedRequestRetryDelayMs:3e4},rt=De({name:"api",initialState:tt,reducers:{setApiConfig(e,t){e.url=t.payload.url,e.apiKey=t.payload.apiKey,"number"==typeof t.payload.throttleDelayMs&&t.payload.throttleDelayMs>=0&&(e.throttleDelayMs=t.payload.throttleDelayMs),"number"==typeof t.payload.cacheLifetime&&t.payload.cacheLifetime>=0?e.cacheLifetimeMs=1e3*t.payload.cacheLifetime:void 0===t.payload.cacheLifetime||(e.cacheLifetimeMs=tt.cacheLifetimeMs,et.warn("apiSlice","Invalid cacheLifetime provided, reset to default.")),"number"==typeof t.payload.failedRequestRetryDelaySeconds&&t.payload.failedRequestRetryDelaySeconds>=0?e.failedRequestRetryDelayMs=1e3*t.payload.failedRequestRetryDelaySeconds:void 0===t.payload.failedRequestRetryDelaySeconds||(e.failedRequestRetryDelayMs=tt.failedRequestRetryDelayMs,et.warn("apiSlice","Invalid failedRequestRetryDelaySeconds provided, reset to default.")),e.error=null,et.log("apiSlice","API config set.",{data:{url:e.url,throttle:e.throttleDelayMs,cacheLifetime:e.cacheLifetimeMs,failedRetryDelay:e.failedRequestRetryDelayMs}})},apiInitializationSuccess(e){e.url&&e.apiKey?(e.initialized=!0,e.error=null,et.log("apiSlice","API marked as initialized successfully.")):(et.warn("apiSlice","Tried to mark API as initialized, but URL or API Key is missing."),e.error="Initialization attempted without full config.")},apiInitializationError(e,t){e.initialized=!1,e.error=t.payload,et.error("apiSlice",`API initialization failed: ${t.payload}`)},clearApiConfig(e){e.url=null,e.apiKey=null,e.initialized=!1,e.error=null,e.throttleDelayMs=tt.throttleDelayMs,e.cacheLifetimeMs=tt.cacheLifetimeMs,e.failedRequestRetryDelayMs=tt.failedRequestRetryDelayMs,et.log("apiSlice","API config cleared.")}}});rt.actions;const at=e=>e.api.initialized,nt=e=>e.api.cacheLifetimeMs;var ot=rt.reducer;const it=e.getInstance();Ce("parameters/initializeConditions",(async(e,{dispatch:t,getState:r,rejectWithValue:a})=>{if(it.log("ParameterThunk","Initializing conditions and parameters...",{rawConditionsCount:e.length}),!e||0===e.length)return it.log("ParameterThunk","No raw conditions provided. Clearing processed conditions."),t(gt([])),void t(mt([]));t(gt(e));const n=r(),o=[],i=new Set;for(let t=0;t<e.length;t++){const r=e[t];let a=null,s="";const c=r.parameter;if(c&&c.startsWith("part:")){{const e=c.split(":");if(3!==e.length){it.warn("ParameterThunk",`Malformed condition parameter string (expected part:id:name): ${c}`,{rawCond:r});continue}{const t=parseInt(e[1],10);if(isNaN(t)){it.warn("ParameterThunk",`Invalid partId in condition parameter string: ${c}`,{rawCond:r});continue}a=t,s=e[2]}}if(null!==a&&s)if(r.operator&&r.action&&void 0!==r.action_value){o.push({id:`cond-${t}-${Date.now()}`,rawConditionString:JSON.stringify(r),sourceParameterString:r.parameter,partId:a,parameterName:s,operator:r.operator,valueToCompare:r.value,action:r.action,actionValue:r.action_value,targetPartIds:r.targetPartIds});const e=At(n,a);"idle"===e?i.add(a):"failed"===e?it.warn("ParameterThunk",`Parameters for part ${a} previously failed to load. Skipping automatic refetch in this cycle. Part: ${a}, ParamName: ${s}`):"loading"===e&&it.log("ParameterThunk",`Parameters for part ${a} are already loading. Skipping. Part: ${a}, ParamName: ${s}`,{level:"debug"})}else it.warn("ParameterThunk","Skipping condition due to missing operator, action, or action_value",{rawCond:r})}else it.warn("ParameterThunk",`Condition parameter string does not follow part:id:name format: ${c}`,{rawCond:r})}if(t(mt(o)),it.log("ParameterThunk",`Processed ${o.length} conditions.`,{processedConditions:o}),i.size>0){const e=Array.from(i);if(it.log("ParameterThunk",`Need to fetch parameters for part IDs: ${e.join(", ")}`),e.length>0)try{await t(ct(e)).unwrap(),it.log("ParameterThunk",`Successfully initiated fetch for referenced parts: ${e.join(", ")}`)}catch(t){it.error("ParameterThunk",`Failed to fetch parameters for referenced parts: ${e.join(", ")}`,{error:t})}}else it.log("ParameterThunk","No new part parameters need to be fetched based on conditions.");try{await t(dt()).unwrap()}catch(e){it.error("ParameterThunk","Error during evaluateAndApplyConditions",{evalError:e})}}));const st=Ce("parameters/fetchForPart",(async(e,t)=>{const r=t.getState(),a=at(r);if(it.log("ParameterThunk",`Fetching parameters for part ID: ${e}`,{category:"parameters",subsystem:"thunk-fetch"}),!a){const e="Direct API is not initialized (checked via apiSlice).";return it.error("ParameterThunk",e,{category:"parameters",subsystem:"thunk-fetch"}),t.rejectWithValue(e)}try{const t=await Ne.getPartParameters(e);if(null===t)throw new Error("API call to getPartParameters returned null.");const r=t.length;return it.log("ParameterThunk",`Successfully fetched ${r} parameters for part ID: ${e}`,{category:"parameters",subsystem:"thunk-fetch"}),{partId:e,parameters:t}}catch(r){const a=`Failed to fetch parameters for part ${e}: ${r.message||r}`;return it.error("ParameterThunk",a,{error:r,category:"parameters",subsystem:"thunk-fetch"}),t.rejectWithValue(a)}})),ct=Ce("parameters/fetchForReferencedParts",(async(e,{getState:t,rejectWithValue:r})=>{const a=t(),n=at(a);if(it.log("fetchParametersForReferencedParts Thunk",`Thunk started. Original partIds received: ${e.join(", ")}`,{level:"debug"}),!n){const e="API not initialized. Cannot fetch referenced parameters.";return it.error("fetchParametersForReferencedParts Thunk",e),r(e)}if(!e||0===e.length)return it.log("fetchParametersForReferencedParts Thunk","No part IDs provided, skipping fetch."),{};const o=e.filter((e=>"failed"!==At(a,e)||(it.warn("fetchParametersForReferencedParts Thunk",`Part ${e} previously failed. Skipping fetch in this batch.`),!1)));if(0===o.length)return it.log("fetchParametersForReferencedParts Thunk","All provided part IDs are already loading, recently failed, or list was empty after filtering. Skipping API calls."),{};it.log("fetchParametersForReferencedParts Thunk",`Attempting to fetch parameters for part IDs: ${o.join(", ")} (after filtering). Original IDs: ${e.join(", ")}`);try{const e={},t=o.map((e=>(it.log("fetchParametersForReferencedParts Thunk",`Preparing API call for partId: ${e}`,{level:"silly"}),Ne.getPartParameters(e).then((t=>({status:"fulfilled",value:t,partId:e}))).catch((t=>({status:"rejected",reason:t,partId:e})))))),r=await Promise.all(t.map((e=>e.catch((e=>e)))));return it.log("fetchParametersForReferencedParts Thunk","Raw settledIndividualPromises:",{data:r,level:"silly"}),r.forEach((t=>{const r=t.partId;if(it.log("fetchParametersForReferencedParts Thunk",`Processing settled promise for partId: ${r}`,{status:t.status,level:"silly"}),"fulfilled"===t.status){const a=t.value;if(null===a){const t=`API returned null or failed to fetch parameters for part ${r}.`;it.warn("fetchParametersForReferencedParts Thunk",t,{partIdForContext:r}),e[r]={data:[],error:t}}else e[r]={data:a},it.log("fetchParametersForReferencedParts Thunk",`Fetched ${a.length} parameters for part ${r}.`,{level:"debug",partIdForContext:r})}else{const a=t.reason||t,n=(null==a?void 0:a.message)||String(a);it.error("fetchParametersForReferencedParts Thunk",`Failed to fetch parameters for part ${r}: ${n}`,{partIdForContext:r,errorDetail:a}),e[r]={data:[],error:n}}})),it.log("fetchParametersForReferencedParts Thunk",`Finished processing parameter fetches for ${o.length} parts.`),it.log("fetchParametersForReferencedParts Thunk","Final results object being returned:",{data:e,level:"debug"}),e}catch(e){const t=`Overall failure in fetchParametersForReferencedParts thunk: ${e.message||e}`;return it.error("fetchParametersForReferencedParts Thunk",t),o.forEach((e=>{})),r(t)}})),lt=Ce("parameters/updateValue",(async({partId:e,paramName:t,value:r},{getState:a,rejectWithValue:n})=>{const o=a();if(!at(o)){const e="API not initialized. Cannot update parameter.";return it.error("updateParameterValue Thunk",e),n(e)}try{const a=(o.parameters.parametersByPartId[e]||[]).find((e=>{var r;return(null===(r=e.template_detail)||void 0===r?void 0:r.name)===t}));if(!a){const r=`Parameter '${t}' not found in state for part ${e}. Cannot get PK for update.`;return it.error("updateParameterValue Thunk",r),n(r)}const i=a.pk;if(!await Ne.updatePartParameter(i,r))throw new Error("API call to updatePartParameter returned null.");return it.log("updateParameterValue Thunk",`Successfully updated param PK ${i} (${t}) for part ${e} to ${r}.`),{partId:e,parameterName:t,value:r}}catch(r){const a=`Failed to update parameter ${t} for part ${e}: ${r.message||r}`;return it.error("updateParameterValue Thunk",a),n(a)}})),dt=Ce("parameters/evaluateAndApplyConditions",(async(e,{dispatch:t,getState:r})=>{var a,n;const o=r(),{processedConditions:i,parameterValues:s}=o.parameters;console.log("[PT_DEBUG] evaluateAndApplyConditions - START. Processed Conditions:",JSON.parse(JSON.stringify(i))),console.log("[PT_DEBUG] evaluateAndApplyConditions - Current parameterValues:",JSON.parse(JSON.stringify(s)));const c=o.parts.partsById;if(!i||0===i.length)return it.log("ParameterThunk","No processed conditions to evaluate. Clearing existing effects."),void t(yt());const l={};for(const e of i){const t=null===(n=null===(a=s[e.partId])||void 0===a?void 0:a[e.parameterName])||void 0===n?void 0:n.data;let r=!1;switch(145===e.partId&&"microwavables"===e.parameterName&&console.log("[PT_DEBUG] Evaluating condition for part:145:microwavables",{conditionSourceString:e.sourceParameterString,operator:e.operator,valueToCompare:e.valueToCompare,paramValueReadFromState:t,currentParameterValuesForPart145:s[145]}),e.operator){case"equals":r=String(t)===String(e.valueToCompare);break;case"not_equals":r=String(t)!==String(e.valueToCompare);break;case"contains":r=String(t).includes(String(e.valueToCompare));break;case"exists":r=null!=t&&""!==t;break;case"is_empty":r=null==t||""===t;break;case"greater_than":r=parseFloat(t)>parseFloat(e.valueToCompare);break;case"less_than":r=parseFloat(t)<parseFloat(e.valueToCompare);break;default:it.warn("ParameterThunk",`Unknown operator: ${e.operator}`,{condition:e})}if(r){console.log("[PT_DEBUG] Condition MET",{conditionSource:e.sourceParameterString,evaluatedParamValue:t,comparedTo:e.valueToCompare,operator:e.operator});let r=[];if("*"===e.targetPartIds?r=Object.keys(c).map((e=>parseInt(e,10))).filter((e=>!isNaN(e))):Array.isArray(e.targetPartIds)&&(r=e.targetPartIds),it.log("ParameterThunk","[DEBUG] Target Part ID Resolution",{level:"info",conditionSource:e.sourceParameterString,rawTargetPartIds:e.targetPartIds,resolvedTargetPartPks:r,targetPartPksLength:r.length}),r.length>0){let t={};switch(e.action){case"filter":t.isVisible="show"===e.actionValue;break;case"highlight":t.highlight=e.actionValue;break;case"text_color":t.textColor=e.actionValue;break;case"border":t.border=e.actionValue;break;case"icon":t.icon=e.actionValue;break;case"badge":t.badge=e.actionValue;break;case"sort":case"priority":case"show_section":it.log("ParameterThunk",`Action type '${e.action}' requires specific handling not yet implemented in basic effects.`,{condition:e});break;default:it.warn("ParameterThunk",`Unknown action type: ${e.action}`,{condition:e})}console.log("[PT_DEBUG] Effect to Apply for MET condition",{conditionSource:e.sourceParameterString,action:e.action,actionValue:e.actionValue,effectToApply:t,targetPartPks:r}),Object.keys(t).length>0?r.forEach((e=>{return a=t,l[r=e]||(l[r]={}),void(l[r]=Object.assign(Object.assign({},l[r]),a));var r,a})):console.warn("[PT_DEBUG] effectToApply is empty, no effect merged.",{conditionSource:e.sourceParameterString,action:e.action,actionValue:e.actionValue,targetPartPks:r})}else it.warn("ParameterThunk","[DEBUG] No target part PKs resolved for MET condition. Effect will not be applied.",{conditionSource:e.sourceParameterString,rawTargetPartIds:e.targetPartIds,conditionAction:e.action,conditionActionValue:e.actionValue})}else it.log("ParameterThunk","Condition NOT MET",{level:"info",conditionSource:e.sourceParameterString,evaluatedParamValue:t,comparedTo:e.valueToCompare,operator:e.operator})}console.log("[PT_DEBUG] Final newEffects before dispatching setConditionalPartEffectsBatch",{newEffects:l}),t(ht(l)),it.log("ParameterThunk","Finished evaluating conditions and dispatched effects batch.",{newEffectsCount:Object.keys(l).length})})),ut=e.getInstance(),pt=De({name:"parameters",initialState:{conditions:{},definedConditions:[],processedConditions:[],conditionalPartEffects:{},actions:{},parameterValues:{},parameterLoadingStatus:{},parameterError:{},config:null,strictWebSocketMode:!1,recentlyChanged:[],cache:{conditionResults:{},lastCleared:Date.now()},parametersByPartId:{}},reducers:{setConditions(e,t){const{entityId:r,conditions:a}=t.payload;e.conditions[r]=a},setDefinedConditions(e,t){e.definedConditions=t.payload,ut.log("parametersSlice","Defined conditions have been set.",{count:t.payload.length,level:"debug"})},setProcessedConditions(e,t){e.processedConditions=t.payload,ut.log("parametersSlice","Processed conditions have been set.",{count:t.payload.length,level:"debug"})},setConditionalPartEffectsBatch(e,t){e.conditionalPartEffects=t.payload,ut.log("parametersSlice","Conditional part effects batch updated.",{count:Object.keys(t.payload).length,level:"debug"})},clearConditionalPartEffects(e){e.conditionalPartEffects={},ut.log("parametersSlice","Conditional part effects cleared.",{level:"debug"})},setActions(e,t){const{entityId:r,actions:a}=t.payload;e.actions[r]=a},setConfig(e,t){e.config=t.payload},setStrictWebSocketMode(e,t){e.strictWebSocketMode=t.payload},clearConditionCache(e){e.cache.conditionResults={},e.cache.lastCleared=Date.now(),ut.log("parametersSlice","Condition cache cleared.",{level:"debug"})},clearCache(e){e.cache.conditionResults={},e.cache.lastCleared=Date.now(),e.parameterValues={},e.parameterLoadingStatus={},e.parameterError={},e.recentlyChanged=[],ut.info("parametersSlice","Full parameter cache cleared (values, status, errors, conditions, recent).")},checkCondition(e,t){},updateValue(e,t){const{partId:r,paramName:a,value:n,source:o}=t.payload;e.parameterValues[r]||(e.parameterValues[r]={},ut.log("parametersSlice",`Created parameter entry for part ${r} during updateValue.`,{level:"debug"})),e.parameterValues[r][a]?e.parameterValues[r][a].data=n:(e.parameterValues[r][a]={pk:0,part:r,template:0,template_detail:{pk:0,name:a,units:"",description:"",checkbox:!1,choices:"",selectionlist:null},data:n,data_numeric:null},ut.log("parametersSlice",`Created parameter entry for ${a} on part ${r} during updateValue.`,{level:"debug"})),"succeeded"!==e.parameterLoadingStatus[r]&&(e.parameterLoadingStatus[r]="succeeded",e.parameterError[r]=null);const i=`${r}:${a}`;e.recentlyChanged.includes(i)||(e.recentlyChanged.push(i),e.recentlyChanged.length>100&&(e.recentlyChanged=e.recentlyChanged.slice(-100))),ut.log("parametersSlice",`Updated value for ${i} to '${n}' (Source: ${o||"Unknown"}). Status set to succeeded.`,{level:"debug"})},webSocketUpdateReceived(e,t){var r,a,n,o;const{partId:i,parameterName:s,value:c,source:l}=t.payload;ut.log("parametersSlice","[Reducer START] webSocketUpdateReceived",{level:"info",partId:i,parameterName:s,receivedValue:c,valueType:typeof c,source:l}),e.parameterValues[i]||(e.parameterValues[i]={},ut.log("parametersSlice",`Created parameter structure for part ${i} during WebSocket update.`,{level:"debug"}));const d=null===(a=null===(r=e.parameterValues[i])||void 0===r?void 0:r[s])||void 0===a?void 0:a.data;ut.log("parametersSlice",`Value before update for ${i}:${s}: ${d}`,{level:"debug"}),e.parameterValues[i][s]?(e.parameterValues[i][s].data=String(c),ut.log("parametersSlice",`Updated existing parameter ${s} for part ${i} via WebSocket. New data: ${String(c)}`,{level:"debug"})):(e.parameterValues[i][s]={pk:0,part:i,template:0,template_detail:{pk:0,name:s,units:"",description:"",checkbox:"boolean"==typeof c,choices:"",selectionlist:null},data:String(c),data_numeric:"number"==typeof c?c:null},ut.log("parametersSlice",`Created new parameter entry for ${s} on part ${i} via WebSocket. New data: ${String(c)}`,{level:"debug"}));const u=null===(o=null===(n=e.parameterValues[i])||void 0===n?void 0:n[s])||void 0===o?void 0:o.data;ut.log("parametersSlice",`Value AFTER update for ${i}:${s}: ${u}`,{level:"debug"}),e.parameterLoadingStatus[i]="succeeded",e.parameterError[i]=null;const p=`${i}:${s}`;e.recentlyChanged.includes(p)||(e.recentlyChanged.push(p),e.recentlyChanged.length>100&&(e.recentlyChanged=e.recentlyChanged.slice(-100))),ut.log("parametersSlice",`[Reducer END] Value for ${p} processed via WebSocket. Status set to succeeded. Final data in store: ${u}`,{level:"info"})},markChanged(e,t){const{parameterId:r}=t.payload;e.recentlyChanged.includes(r)||(e.recentlyChanged.push(r),e.recentlyChanged.length>100&&(e.recentlyChanged=e.recentlyChanged.slice(-100)))},addParametersForPart(e,t){const{partId:r,parameters:a}=t.payload;e.parametersByPartId[r]||(e.parametersByPartId[r]=[]),e.parametersByPartId[r]=[...e.parametersByPartId[r],...a]},updateParameterForPart(e,t){const{partId:r,parameterName:a,value:n}=t.payload,o=e.parametersByPartId[r];if(o){const e=o.findIndex((e=>{var t;return(null===(t=e.template_detail)||void 0===t?void 0:t.name)===a}));-1!==e?(o[e]=Object.assign(Object.assign({},o[e]),{data:n}),ut.log("ParameterSlice",`Updated parameter '${a}' for part ${r} to value: ${n}`,{level:"debug"})):ut.warn("ParameterSlice",`Parameter '${a}' not found for part ${r} during update.`)}else ut.warn("ParameterSlice",`Part ${r} not found in parametersByPartId during update.`)}},extraReducers:e=>{e.addCase(st.pending,((e,t)=>{const r=t.meta.arg;e.parameterLoadingStatus[r]="loading",e.parameterError[r]=null,ut.log("parametersSlice",`Fetching parameters for part ${r}...`,{level:"debug"})})).addCase(st.fulfilled,((e,t)=>{const{partId:r,parameters:a}=t.payload;e.parameterLoadingStatus[r]="succeeded",e.parameterError[r]=null,e.parameterValues[r]||(e.parameterValues[r]={}),a.length>0?(a.forEach((t=>{var a;const n=null===(a=t.template_detail)||void 0===a?void 0:a.name;n?e.parameterValues[r][n]=t:ut.warn("parametersSlice",`Fetched parameter for part ${r} is missing template_detail.name`,t)})),ut.log("parametersSlice",`Successfully fetched ${a.length} parameters for part ${r}.`,{level:"debug"})):ut.log("parametersSlice",`Fetched parameters for part ${r}, but received an empty array. Marking as succeeded.`,{level:"debug"})})).addCase(st.rejected,((e,t)=>{var r;const a=t.meta.arg;e.parameterLoadingStatus[a]="failed",e.parameterError[a]=null!==(r=t.payload)&&void 0!==r?r:"Failed to fetch parameters",ut.error("parametersSlice",`Failed to fetch parameters for part ${a}: ${e.parameterError[a]}`)})).addCase(ct.pending,((e,t)=>{ut.log("parametersSlice","Handling fetchParametersForReferencedParts.pending",{level:"debug",subsystem:"thunkStatus"});const r=t.meta.arg;ut.log("parametersSlice",`- Pending for partIds from thunk argument: ${r.join(", ")}`,{level:"debug",subsystem:"thunkStatus",data:r}),r.forEach((t=>{var r;const a=null!==(r=e.parameterLoadingStatus[t])&&void 0!==r?r:"idle";"idle"===a||"failed"===a?(e.parameterLoadingStatus[t]="loading",e.parameterError[t]=null,ut.log("parametersSlice",`Set part ${t} to loading (was ${a})`,{level:"silly"})):ut.log("parametersSlice",`Part ${t} already ${a}, not changing to loading in pending reducer.`,{level:"silly"})}))})).addCase(ct.fulfilled,((e,t)=>{const r=t.payload;ut.log("parametersSlice","Handling fetchParametersForReferencedParts.fulfilled",{level:"debug",subsystem:"thunkStatus",data:r}),Object.entries(r).forEach((([t,r])=>{const a=parseInt(t,10);if(r.error)e.parameterLoadingStatus[a]="failed",e.parameterError[a]=r.error,e.parameterValues[a]||(e.parameterValues[a]={}),ut.warn("parametersSlice",`fetchParametersForReferencedParts fulfilled but part ${a} failed: ${r.error}`);else{e.parameterLoadingStatus[a]="succeeded",e.parameterError[a]=null,e.parameterValues[a]||(e.parameterValues[a]={});const t={};r.data.length>0&&r.data.forEach((e=>{var r;const n=null===(r=e.template_detail)||void 0===r?void 0:r.name;n?t[n]=e:ut.warn("parametersSlice",`Fetched parameter for part ${a} is missing template_detail.name`,{paramData:e})})),e.parameterValues[a]=t,ut.log("parametersSlice",`Updated parameters for part ${a}. Count: ${r.data.length}.`,{level:"debug"})}}))})).addCase(ct.rejected,((e,t)=>{ut.error("parametersSlice",`Handling fetchParametersForReferencedParts.rejected: ${t.payload||t.error.message}`,{subsystem:"thunkStatus",error:t.payload||t.error});const r=t.meta.arg;r&&Array.isArray(r)&&r.forEach((r=>{"loading"===e.parameterLoadingStatus[r]&&(e.parameterLoadingStatus[r]="failed",e.parameterError[r]=t.payload||t.error.message||"Thunk rejected")}))})).addCase(lt.pending,((e,t)=>{const{partId:r,paramName:a}=t.meta.arg;ut.log("parametersSlice",`Updating parameter ${a} for part ${r}...`,{level:"debug"})})).addCase(lt.fulfilled,((e,t)=>{const{partId:r,paramName:a,value:n}=t.payload,o=`${r}:${a}`;e.parameterValues[r]&&e.parameterValues[r][a]?(e.parameterValues[r][a].data=n,ut.log("parametersSlice",`Successfully updated parameter ${o} to '${n}' via API.`,{level:"debug"})):ut.warn("parametersSlice",`Parameter ${o} not found in state during updateParameterValue.fulfilled. Value set by API might not be reflected unless fetched.`),e.parameterLoadingStatus[r]="succeeded",e.parameterError[r]=null,e.recentlyChanged.includes(o)||(e.recentlyChanged.push(o),e.recentlyChanged.length>100&&(e.recentlyChanged=e.recentlyChanged.slice(-100)))})).addCase(lt.rejected,((e,t)=>{const{partId:r,paramName:a}=t.meta.arg,n=`${r}:${a}`;ut.error("parametersSlice",`Failed to update parameter ${n} via API: ${t.payload}`)}))}}),{setConditions:ft,setDefinedConditions:gt,setProcessedConditions:mt,setConditionalPartEffectsBatch:ht,clearConditionalPartEffects:yt,setActions:vt,setConfig:St,setStrictWebSocketMode:bt,clearConditionCache:wt,clearCache:kt,checkCondition:Pt,updateValue:It,webSocketUpdateReceived:$t,markChanged:Ct,addParametersForPart:_t,updateParameterForPart:Et}=pt.actions,At=(e,t)=>{var r;return null!==(r=e.parameters.parameterLoadingStatus[t])&&void 0!==r?r:"idle"};var Tt=pt.reducer;const jt=De({name:"ui",initialState:{activeView:"detail",selectedPartId:null,debug:{showDebugPanel:!1,activeTab:"data"},loading:!1},reducers:{setActiveView(e,t){e.activeView=t.payload},setSelectedPart(e,t){e.selectedPartId=t.payload},toggleDebugPanel(e){e.debug.showDebugPanel=!e.debug.showDebugPanel},setDebugTab(e,t){e.debug.activeTab=t.payload},setLoading(e,t){e.loading=t.payload}}});jt.actions;var Dt=jt.reducer;const Rt=new Map,Ot=new Map;const Ft=De({name:"timers",initialState:{timers:{},componentTimers:{},lastId:0},reducers:{addTimer:(e,t)=>{const{componentId:r,label:a,startTime:n,delay:o,type:i}=t.payload,s=++e.lastId;e.timers[s]={id:s,componentId:r,label:a,startTime:n,delay:o,type:i},e.componentTimers[r]||(e.componentTimers[r]=new Set),e.componentTimers[r].add(s)},removeTimer:(e,t)=>{const r=t.payload,a=e.timers[r];a&&(e.componentTimers[a.componentId]&&(e.componentTimers[a.componentId].delete(r),0===e.componentTimers[a.componentId].size&&delete e.componentTimers[a.componentId]),delete e.timers[r])},clearComponentTimers:(e,t)=>{const r=t.payload,a=e.componentTimers[r];a&&(a.forEach((t=>{delete e.timers[t]})),delete e.componentTimers[r])},clearAllTimers:e=>{e.timers={},e.componentTimers={}}}}),{addTimer:Mt,removeTimer:Nt,clearComponentTimers:xt,clearAllTimers:Vt}=Ft.actions;function Lt(e){return(t,r)=>{const a=((e,t)=>Object.values(e.timers.timers).filter((e=>null!==e&&"object"==typeof e&&"componentId"in e&&e.componentId===t)))(r(),e);a.forEach((e=>{var t;"timeout"===e.type?(t=e.id,window.clearTimeout(t),Rt.delete(t)):function(e){window.clearInterval(e),Ot.delete(e)}(e.id)})),t(xt(e))}}var Wt=Ft.reducer;const Bt=e.getInstance(),qt={status:"idle",lastMessage:null,lastError:null,messageCount:0},zt=De({name:"websocket",initialState:qt,reducers:{setWebSocketStatus:(e,t)=>{Bt.log("WebSocketSlice",`Status changing from ${e.status} to ${t.payload}`),e.status=t.payload,"error"===t.payload?e.lastError="An error occurred":e.lastError=null},webSocketMessageReceived:(e,t)=>{e.lastMessage=t.payload,e.messageCount+=1,Bt.log("WebSocketSlice",`Message received (Count: ${e.messageCount})`,t.payload)},resetWebSocketState:e=>{Bt.log("WebSocketSlice","Resetting WebSocket state"),Object.assign(e,qt)}}}),{setWebSocketStatus:Ut,webSocketMessageReceived:Kt,resetWebSocketState:Gt}=zt.actions;var Jt=zt.reducer;const Yt=De({name:"components",initialState:{registeredComponents:{}},reducers:{registerComponent:(e,t)=>{const r=t.payload,a=Date.now();e.registeredComponents[r]={isActive:!0,registeredAt:a,lastActive:a}},disconnectComponent:(e,t)=>{const r=t.payload;e.registeredComponents[r]&&(e.registeredComponents[r].isActive=!1)},reconnectComponent:(e,t)=>{const r=t.payload,a=Date.now();e.registeredComponents[r]?(e.registeredComponents[r].isActive=!0,e.registeredComponents[r].lastActive=a):e.registeredComponents[r]={isActive:!0,registeredAt:a,lastActive:a}},updateComponentActivity:(e,t)=>{const r=t.payload;e.registeredComponents[r]&&(e.registeredComponents[r].lastActive=Date.now())},removeComponent:(e,t)=>{const r=t.payload;e.registeredComponents[r]&&delete e.registeredComponents[r]}}});Yt.actions;var Ht=Yt.reducer;const Xt=e.getInstance(),Qt=Ce("search/perform",(async(e,t)=>{try{Xt.log("performSearch",`Searching for: "${e}"`,{level:"debug"});const t=(await Ne.getParts({search:e})).map((e=>({pk:e.pk,name:e.name,thumbnail:e.thumbnail||void 0})));return Xt.log("performSearch",`Search successful, found ${t.length} results.`),t}catch(e){const r=e.message||"Failed to perform search";return Xt.error("performSearch",`Search failed: ${r}`,e),t.rejectWithValue("string"==typeof e?e:r)}}));Ce("search/searchInventree",(async(e,{getState:t,rejectWithValue:r})=>{t(),Xt.warn("searchInventree Thunk","Attempting to create API instance inside thunk - this should be refactored.");try{Xt.warn("searchInventree Thunk","Using MOCKED API response"),await new Promise((e=>setTimeout(e,500)));const t=e.toLowerCase().includes("resistor")?[{pk:101,name:"Resistor 1k",in_stock:100,thumbnail:""},{pk:102,name:"Resistor 10k",in_stock:50,thumbnail:""}]:[];return Xt.log("searchInventree Thunk",`Search for "${e}" returned ${t.length} results.`),t}catch(e){return Xt.error("searchInventree Thunk",`Search failed: ${e.message||e}`),r(e.message||"Search failed")}}));const Zt=e.getInstance(),er=De({name:"search",initialState:{query:"",results:[],loading:"idle",error:null},reducers:{setSearchQuery:(e,t)=>{e.query=t.payload,Zt.log("searchSlice",`Search query set to: "${t.payload}"`,{level:"debug"})},clearSearch:e=>{e.query="",e.results=[],e.loading="idle",e.error=null,Zt.log("searchSlice","Search state cleared.",{level:"debug"})}},extraReducers:e=>{e.addCase(Qt.pending,(e=>{e.loading="pending",e.error=null,Zt.log("searchSlice","Search pending...",{level:"debug"})})).addCase(Qt.fulfilled,((e,t)=>{e.loading="succeeded",e.results=t.payload,e.error=null,Zt.log("searchSlice",`Search succeeded with ${t.payload.length} results.`,{level:"debug"})})).addCase(Qt.rejected,((e,t)=>{var r;e.loading="failed",e.error=null!==(r=t.payload)&&void 0!==r?r:"Search failed",e.results=[],Zt.error("searchSlice",`Search failed: ${e.error}`)}))}});er.actions;var tr=er.reducer;const rr=e.getInstance(),ar=De({name:"visualEffects",initialState:{effectsByPartId:{}},reducers:{setVisualEffect(e,t){const{partId:r,effect:a}=t.payload;e.effectsByPartId[r]||(e.effectsByPartId[r]={}),e.effectsByPartId[r]=Object.assign(Object.assign({},e.effectsByPartId[r]),a),rr.log("visualEffectsSlice",`Visual effect set/merged for part ${r}.`,{partId:r,newEffect:a,level:"debug"})},setVisualEffectsBatch(e,t){e.effectsByPartId=t.payload,rr.log("visualEffectsSlice","Visual effects batch updated.",{count:Object.keys(t.payload).length,level:"debug"})},clearVisualEffect(e,t){const r=t.payload;delete e.effectsByPartId[r],rr.log("visualEffectsSlice",`Visual effects cleared for part ${r}.`,{partId:r,level:"debug"})},clearAllVisualEffects(e){e.effectsByPartId={},rr.log("visualEffectsSlice","All visual effects cleared.",{level:"debug"})}}});ar.actions;var nr=ar.reducer;const or=e.getInstance(),ir=De({name:"config",initialState:{dataSources:{primary:{entityId:null},additional:{entities:[],directPartIds:[],categories:[]},inventreeParametersToFetch:[],api:{enabled:!1,url:null,apiKey:null,websocketUrl:null},bindings:{},refresh:{pollingInterval:300,websocketEnabled:!0,cacheLifetime:60}},objectTransformations:{filters:[],derivedProperties:[],sorting:[],grouping:{groupByProperty:null,enabled:!1},resolveVariants:!1},expressions:{},presentation:{viewType:"detail",layout:{},display:{showImage:!0,showName:!0,showStock:!0,showDescription:!1,showCategory:!1,showIPN:!1,showLocation:!1,showButtonsArea:!0,showParametersSection:!0},styling:{},conditionalRules:{}},interactions:{buttons:{}},system:{performance:{rendering:{debounceTime:50,idleRenderInterval:5e3,maxRenderFrequency:10},websocket:{reconnectInterval:5e3,messageDebounce:50},api:{throttle:.2,cacheLifetime:60,batchSize:20,failedRequestRetryDelaySeconds:30},parameters:{updateFrequency:1e3,conditionEvalFrequency:1e3}},debug:{enabled:!1,verbose:!1,hierarchical:{}}},configVersion:"1.0.0",lastSaved:void 0},reducers:{setFullConfig(e,t){Object.assign(e,t.payload),e.lastSaved=(new Date).toISOString(),or.log("configSlice","Full configuration set and updated lastSaved.",{newConfig:t.payload})},setDataSourcesConfig(e,t){e.dataSources=Object.assign(Object.assign({},e.dataSources),t.payload),e.lastSaved=(new Date).toISOString(),or.log("configSlice","DataSources configuration updated.",{updates:t.payload})},setObjectTransformationsConfig(e,t){e.objectTransformations=Object.assign(Object.assign({},e.objectTransformations),t.payload),e.lastSaved=(new Date).toISOString()},setExpressionsConfig(e,t){e.expressions=t.payload,e.lastSaved=(new Date).toISOString()},setPresentationConfig(e,t){e.presentation=Object.assign(Object.assign({},e.presentation),t.payload),e.lastSaved=(new Date).toISOString()},setInteractionsConfig(e,t){e.interactions=Object.assign(Object.assign({},e.interactions),t.payload),e.lastSaved=(new Date).toISOString()},setSystemConfig(e,t){t.payload.performance&&(e.system.performance=Object.assign(Object.assign({},e.system.performance),t.payload.performance)),t.payload.debug&&(e.system.debug=Object.assign(Object.assign({},e.system.debug),t.payload.debug)),e.lastSaved=(new Date).toISOString()},setApiConfig(e,t){e.dataSources.api=Object.assign(Object.assign({},e.dataSources.api),t.payload),e.lastSaved=(new Date).toISOString(),or.log("configSlice","API configuration within DataSources updated.",{updates:t.payload})}}});ir.actions;var sr=ir.reducer;const cr=e.getInstance(),lr=e=>t=>r=>{const a=performance.now();cr.log("Redux Middleware",`🚀 Action Dispatched: ${r.type}`,{category:"redux",subsystem:"action",data:r.payload});const n=t(r),o=performance.now()-a;if(cr.log("Redux Middleware",`⏱️ Action Completed: ${r.type} (${o.toFixed(2)}ms)`,{category:"redux",subsystem:"performance"}),cr.isEnabled("redux","state")){const t=e.getState();cr.log("Redux Middleware",`🔄 State After Action: ${r.type}`,{category:"redux",subsystem:"state",data:t})}return n},dr=e.getInstance(),ur=e=>e=>t=>{if(dr.log("Redux",`Action dispatched: ${t.type}`,{category:"redux",subsystem:"middleware"}),"parts/fetchParts/fulfilled"===t.type){const{entityId:e,data:r}=t.payload,a=`entity-data:${e}`;Cr.getInstance().set(a,r),dr.log("Redux",`Updated service data for entity ${e}`,{category:"redux",subsystem:"sync"})}if("parameters/updateValue"===t.type){const{partId:e,parameterName:r,value:a}=t.payload;Pr.dispatch(lt({partId:e,parameterName:r,value:a})),dr.log("Redux",`Dispatched updateParameterValue thunk for ${r}`,{})}if("parameters/checkCondition"===t.type){const{part:e,condition:r}=t.payload;dr.log("Redux",`Checking condition for part ${null==e?void 0:e.pk}`,{category:"redux",subsystem:"parameters",condition:r})}return"parameters/clearConditionCache"!==t.type&&"parameters/clearCache"!==t.type||dr.log("Redux","Clearing parameter cache",{category:"redux",subsystem:"parameters"}),e(t)},pr=e=>t=>r=>{if("components/disconnectComponent"===r.type){const t=r.payload;e.dispatch(Lt(t))}return t(r)},fr=e.getInstance();let gr=0,mr=null;const hr=e=>t=>r=>{var a;const n=t(r);if(Kt.match(r)){const t=r.payload;if("object"==typeof t&&null!==t&&"event"===t.type&&"string"==typeof t.event&&"object"==typeof t.data&&null!==t.data){const r=t.event,n=t.data;if(fr.log("WebSocketMiddleware",`Processing event: ${r}`,{eventData:n,level:"info"}),r.includes("part_partparameter.saved")||r.includes("part_partparameter.created")){const t=n;fr.log("WebSocketMiddleware","Parameter event data:",{data:t,level:"debug"});const r=null!==(a=t.part_pk)&&void 0!==a?a:t.parent_id,o=t.parameter_name,i=t.parameter_value;void 0!==r&&void 0!==o&&void 0!==i?(fr.log("WebSocketMiddleware",`Dispatching parameters/updateValue (direct action) for Part ${r}, Param ${o} to value ${i}`,{level:"info"}),e.dispatch(It({partId:Number(r),paramName:String(o),value:String(i),source:"websocket"})),setTimeout((()=>{var t,r,a;const n=e.getState().parameters.config,o=null!==(a=null===(r=null===(t=null==n?void 0:n.performance)||void 0===t?void 0:t.parameters)||void 0===r?void 0:r.conditionEvalFrequency)&&void 0!==a?a:1e3,i=Date.now();if(mr&&(clearTimeout(mr),mr=null,fr.log("WebSocketMiddleware","Cleared pending (trailing) evaluateAndApplyConditions call due to new trigger.",{level:"silly"})),i-gr>o)fr.log("WebSocketMiddleware",`Dispatching evaluateAndApplyConditions (direct). Interval: ${o}ms. lastEval: ${gr}, now: ${i}`,{level:"info"}),e.dispatch(dt()),gr=i;else{const t=Math.max(0,o-(i-gr));fr.log("WebSocketMiddleware",`Throttling evaluateAndApplyConditions. Scheduling trailing call. Delay: ${t}ms. lastEval: ${gr}, now: ${i}`,{level:"info"}),mr=setTimeout((()=>{fr.log("WebSocketMiddleware",`Dispatching evaluateAndApplyConditions (trailing call). Interval: ${o}ms.`,{level:"info"}),e.dispatch(dt()),gr=Date.now(),mr=null}),t)}}),0)):fr.warn("WebSocketMiddleware","Received parameter update, but missing key data fields.",{paramData:t})}else if(r.includes("stock_stockitem.saved")||r.includes("stock_stockitem.created")){const t=n,r=t.part_id;void 0!==r?(fr.log("WebSocketMiddleware",`Dispatching partStockUpdateFromWebSocket for Part ${r}`),e.dispatch(Je({partId:Number(r),quantity:t.quantity,batch:t.batch,serial:t.serial,status_label:t.status_label,status_value:t.status_value,last_updated:t.last_updated,part_name:t.part_name,part_ipn:t.part_ipn,part_thumbnail:t.part_thumbnail,location_id:t.location_id,location_name:t.location_name,location_pathstring:t.location_pathstring,stockItemId:t.id})),fr.log("WebSocketMiddleware",`Dispatching fetchPartDetails for Part ${r} due to stock event.`),e.dispatch(Ve(Number(r)))):fr.warn("WebSocketMiddleware","Received stock update, but missing part_id.",{stockData:t})}else fr.log("WebSocketMiddleware",`Received unhandled event type: ${r}`,{eventData:n})}else fr.warn("WebSocketMiddleware","Received webSocketMessageReceived action, but payload was not a valid WebSocketEventMessage structure",{payload:r.payload})}return"websocket/connect"===r.type?fr.log("WebSocket Middleware","Explicit connect action received (currently informational)"):"websocket/disconnect"===r.type&&fr.log("WebSocket Middleware","Explicit disconnect action received (currently informational)"),n},yr=e.getInstance(),vr=new Map,Sr={"parameters/webSocketUpdateReceived":250},br=e=>e=>t=>{const r=t.type;if(!Sr[r])return e(t);{const a=Sr[r],n=`${r}:${JSON.stringify(t.payload||{})}`;yr.log("DebounceMiddleware",`Debouncing action: ${r}, Key: ${n}, Time: ${a}ms`),vr.has(n)&&clearTimeout(vr.get(n));const o=setTimeout((()=>{yr.log("DebounceMiddleware",`Executing debounced action: ${r}, Key: ${n}`),vr.delete(n),e(t)}),a);vr.set(n,o)}},wr=e.getInstance(),kr=e=>e=>t=>{const r=e(t);if("metrics/trackEvent"===t.type){const{category:e,action:r,label:a,value:o}=t.payload;try{n(e,r,{label:a,value:o,source:"redux"}),wr.log("MetricsMiddleware",`Tracked event: ${e}/${r}`,{category:"metrics",data:t.payload})}catch(e){wr.error("MetricsMiddleware",`Error tracking usage: ${e}`,{category:"metrics",error:e})}}return r},Pr=function(e){const t=function(e){const{thunk:t=!0,immutableCheck:r=!0,serializableCheck:a=!0,actionCreatorCheck:n=!0}=e??{};let o=new ge;return t&&("boolean"==typeof t?o.push(de):o.push(ue(t.extraArgument))),o},{reducer:r,middleware:a,devTools:n=!0,duplicateMiddlewareCheck:i=!0,preloadedState:s,enhancers:c}=e||{};let f,g;if("function"==typeof r)f=r;else{if(!l(r))throw new Error(Oe(1));f=u(r)}g="function"==typeof a?a(t):t();let m=p;n&&(m=pe({trace:!1,..."object"==typeof n&&n}));const h=function(...e){return t=>(r,a)=>{const n=t(r,a);let i=()=>{throw new Error(o(15))};const s={getState:n.getState,dispatch:(e,...t)=>i(e,...t)},c=e.map((e=>e(s)));return i=p(...c)(n.dispatch),{...n,dispatch:i}}}(...g),y=ve(h);return d(f,s,m(..."function"==typeof c?c(y):y()))}({reducer:{parts:He,parameters:Tt,ui:Dt,timers:Wt,websocket:Jt,components:Ht,search:tr,api:ot,visualEffects:nr,config:sr},middleware:e=>e({serializableCheck:!1}).concat(lr,ur,pr,hr,br,kr)}),Ir={ENTITY_DATA:3e4,PARAMETER:6e4,RENDER_DEDUP:300,WS_DEDUP:500,CONDITION:2e3,FALLBACK:6e4};var $r;!function(e){e.ENTITY="entity",e.PARAMETER="parameter",e.RENDER="render",e.WEBSOCKET="websocket",e.CONDITION="condition",e.GENERAL="general"}($r||($r={}));class Cr{constructor(){this.cache=new Map,this._fallbackValues=new Map,this._missCallbacks=new Map,this._pruneIntervalId=null,this._isDestroyed=!1,this._useRedux=!0,this.logger=e.getInstance();try{this._useRedux=!0,this.logger.log("CacheService","CacheService instance created"),n("cache","initialize",{source:this._useRedux?"redux":"legacy"})}catch(e){this._useRedux=!1,this.logger.error("Cache","Error during feature flag check, using fallback timer implementation",{category:"cache",subsystem:"errors",error:e})}this._startPruneInterval()}_startPruneInterval(){if(!this._isDestroyed&&null===this._pruneIntervalId)try{n("cache","startPruneInterval",{source:this._useRedux?"redux":"legacy"}),this._pruneIntervalId=setInterval((()=>{this._isDestroyed||this.prune()}),6e4),this.logger.log("Cache","Prune interval started",{category:"cache",subsystem:this._useRedux?"redux":"legacy"})}catch(e){if(this.logger.error("Cache",`Failed to start prune interval: ${e}`,{category:"cache",subsystem:"errors"}),!this._pruneIntervalId)try{this._pruneIntervalId=setTimeout((()=>{this._isDestroyed||this.prune()}),6e4),this.logger.log("Cache","Prune interval started with fallback timer",{category:"cache"})}catch(e){this.logger.error("Cache",`Failed to start fallback prune interval: ${e}`,{category:"cache",subsystem:"errors"})}}}static getInstance(){return Cr.instance||(Cr.instance=new Cr),Cr.instance}set(e,t,r,a=$r.GENERAL){if(this._isDestroyed)return;n("cache","set",{category:a,source:this._useRedux?"redux":"legacy"});let o=r;if(void 0===o)if(a===$r.ENTITY||a===$r.PARAMETER){const t=nt(Pr.getState());t>0?(o=t,this.logger.log("Cache",`Using configured API cache lifetime for ${e}: ${o}ms`,{category:"cache",subsystem:a})):(o=a===$r.ENTITY?Ir.ENTITY_DATA:Ir.PARAMETER,this.logger.log("Cache",`Using default API cache lifetime for ${e}: ${o}ms (configured was ${t}ms)`,{category:"cache",subsystem:a}))}else o=e.startsWith("render:")?Ir.RENDER_DEDUP:e.startsWith("ws-")||e.startsWith("websocket:")?Ir.WS_DEDUP:e.startsWith("condition:")?Ir.CONDITION:Ir.FALLBACK;else if(r===Ir.FALLBACK&&(a===$r.ENTITY||a===$r.PARAMETER)){const e=nt(Pr.getState());e>0&&(o=e)}("number"!=typeof o||o<=0)&&(this.logger.warn("Cache",`Invalid or zero TTL determined for key ${e}. Using fallback TTL: ${Ir.FALLBACK}ms`,{category:"cache",subsystem:a,determinedTtl:o}),o=Ir.FALLBACK),this.cache.set(e,{value:t,timestamp:Date.now(),ttl:o,category:a}),this.logger.log("Cache",`Set ${e}, expires in ${o}ms`,{category:"cache",subsystem:a})}get(e,t=!0){const r=this.cache.get(e);if(r){if(!(r.timestamp+r.ttl<Date.now()))return t&&this._fallbackValues.set(e,r.value),this.logger.log("Cache",`Hit: ${e}`,{category:"cache",subsystem:r.category}),r.value;if(this.cache.delete(e),this.logger.log("Cache",`Miss: ${e} (expired)`,{category:"cache",subsystem:r.category}),this._handleCacheMiss(e),t&&this._fallbackValues.has(e)){const t=this._fallbackValues.get(e);return this.logger.log("Cache",`Using fallback for ${e} (expired)`,{category:"cache"}),t}}else if(this.logger.log("Cache",`Miss: ${e} (not found)`,{category:"cache"}),this._handleCacheMiss(e),t&&this._fallbackValues.has(e)){const t=this._fallbackValues.get(e);return this.logger.log("Cache",`Using fallback for ${e}`,{category:"cache"}),t}}_handleCacheMiss(e){if(this._missCallbacks.has(e)){const t=this._missCallbacks.get(e);t&&(this.logger.log("Cache",`Executing miss callback for ${e}`,{category:"cache"}),t().then((t=>{if(void 0!==t){let r=Ir.FALLBACK;e.startsWith("entity-data:")&&(r=Ir.ENTITY_DATA),this.set(e,t,r),this.logger.log("Cache",`Miss callback successfully updated ${e}`,{category:"cache"})}})).catch((t=>{this.logger.error("Cache",`Error in miss callback for ${e}: ${t}`,{category:"cache"})})))}}registerMissCallback(e,t){this._missCallbacks.set(e,t),this.logger.log("Cache",`Registered miss callback for ${e}`,{category:"cache"})}setFallback(e,t){this._fallbackValues.set(e,t),this.logger.log("Cache",`Set fallback value for ${e}`,{category:"cache"})}has(e){const t=this.cache.get(e);return!!t&&(!(t.timestamp+t.ttl<Date.now())||(this.cache.delete(e),!1))}updateTTL(e,t){if(this._isDestroyed)return!1;const r=this.cache.get(e);return!!r&&(this.cache.set(e,Object.assign(Object.assign({},r),{ttl:t})),this.logger.log("Cache",`Updated TTL for ${e}, new expiry in ${t}ms`,{category:"cache"}),!0)}refreshEntityCache(e){const t=`entity-data:${e}`;return this.updateTTL(t,Ir.ENTITY_DATA)}delete(e){const t=this.cache.get(e);this.cache.delete(e),t?this.logger.log("Cache",`Deleted ${e}`,{category:"cache",subsystem:t.category}):this.logger.log("Cache",`Attempted to delete non-existent key: ${e}`,{category:"cache"})}prune(){const e=Date.now();let t=0;const r={};for(const[a,n]of this.cache.entries())if(n.timestamp+n.ttl<e){this.cache.delete(a),t++;const e=n.category||$r.GENERAL;r[e]=(r[e]||0)+1}if(t>0){const e=Object.entries(r).map((([e,t])=>`${e}: ${t}`)).join(", ");this.logger.log("Cache",`Pruned ${t} expired entries (${e})`,{category:"cache"})}}clear(){const e=this.cache.size;this.cache.clear(),this._fallbackValues.clear(),this.logger.log("Cache",`Cleared ${e} entries`,{category:"cache"})}getStats(){const e=Date.now();let t=0;const r={};for(const[a,n]of this.cache.entries()){const a=n.category||$r.GENERAL;r[a]=(r[a]||0)+1,n.timestamp+n.ttl<e&&t++}return{size:this.cache.size,expired:t,byCategory:r,fallbackCount:this._fallbackValues.size}}getKeys(){return Array.from(this.cache.keys())}clearPattern(e){let t=0;const r=[];for(const a of this.cache.keys())a.includes(e)&&(r.push(a),t++);for(const e of r){const t=this.cache.get(e);this.cache.delete(e),t&&this.logger.log("Cache",`Deleted ${e} by pattern match`,{category:"cache",subsystem:t.category})}return this.logger.log("Cache",`Cleared ${t} entries matching pattern: ${e}`,{category:"cache"}),t}clearEntityCache(){return this.clearPattern("entity-data:")}clearConditionCache(){return this.clearPattern("condition:")}clearRenderCache(){return this.clearPattern("render:")}clearWebSocketCache(){return this.clearPattern("ws-")+this.clearPattern("websocket:")}destroy(){if(this._isDestroyed=!0,n("cache","destroy",{source:this._useRedux?"redux":"legacy"}),null!==this._pruneIntervalId){try{clearInterval(this._pruneIntervalId)}catch(e){this.logger.error("Cache",`Error clearing prune interval: ${e}`,{category:"cache",subsystem:"errors"})}this._pruneIntervalId=null}this.clear(),this.logger.log("Cache","Cache service destroyed and resources released",{category:"cache",subsystem:this._useRedux?"redux":"legacy"})}}export{$r as CacheCategory,Cr as CacheService,Ir as DEFAULT_TTL};
//# sourceMappingURL=cache-17abc121.js.map
